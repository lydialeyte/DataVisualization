<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="keywords" content="livability, netherlands, wealth, moving, internationality">
  <meta name="author" content="Group 2">
  <title>Livability in the Netherlands</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <link rel="stylesheet" href="scrolly.css">
</head>

<body id="home">
  <header>
    <h1>Livability in the Netherlands</h1>
    <p>Exploring socioeconomic and geospatial accessibility metrics that influence livability scores in the Netherlands</p>
  </header>

  <section class="introduction">
    <p>
      Welcome to our .... <br>
    </p>
    <p>
      Livability = ... . It is relevant to look at because ... .
    </p>
    <p>
      Here, you can select a region of interest to analyze the trends in livability data of that location over time. This can be done at three granularities, namely that of municipalities, districts, or neighborhoods. 
      After finding and selecting you region of interest, you may also select up to 5 (?) regions of the same granularity to which you would like to compare your region of interest. 
      When you are satisfied with your anlyses of the livability scores over time, you may move on to the next part of this page to analyze which socioeconomic and geospatial accessibility factors may be improved to improve the livability score in your region of interest.
    </p>
    <p>
      Find your region of interest in the map of the Netherlands below, or look it up. Then, find regions you would like to compare your region to by ... .
    </p>
  </section>
  
  <section class="controls-container" >
    <h3 style="padding-left:50px;" id="current-city">
      Current selected city: <span id="selected-city">No city selected</span>
    </h3>
  </section>
  
    <div>
      <p> All regions are clustered based on the trends their livability scores follow over time. In the line graph on the left, the average livability scores of these clusters can be seen. 
      In the geographical map, regions are collored according to their cluster so you may see what your region belongs to, and compare it </p>
    </div>
  <div class="chart-container">

    <!-- Placeholder for the Line Graph -->
    <div id="line-graph" class="chart"></div>

    <!-- Placeholder for the Geographic Map -->
    <div id="geo-map" class="chart">
    <div id="tooltip" style="position: absolute; z-index: 1000; display: none; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; padding: 10px; font-size: 12px; pointer-events: none;"></div>
 
      
      <!-- Placeholder for Loading Icon -->
      <div id="loading-icon" style="display: none;">
        <p>Loading...</p> 
      </div>
      
    </div>

  </div>
  <div class="chart-container">
  <div id="legend" class="legend-container"></div>
   </div>

  <section id="factor-list-container" class="factor-list-container">
    <div id="search-container" class="search-container">
      <input type="text" id="factor-search" placeholder="Add a factor to the plots" autocomplete="off">
      <button id="add-button">ADD</button>
      <div id="suggestions"></div>
    </div>
    <h3 style="padding-left:50px;">Selected Factors:</h3>
    <ul style="padding-left:60px;"id="factor-list"></ul>
    <div id="scatter-plot-container"></div>
  </section>
  
  

  <script>
    // State Configurations
    const state = { //default configuration of the application 
      year: 2020,
      city: "GM0014",
      granularity: "gemeente" // Default granularity
    };

    // data set paths for geographic maps 
    const datasets = {
      buurt: "data/simplified_file.geojson", // Buurt dataset (dummy)
      wijk: "data/merged_data_reprojected_WK_1.geojson",  // Wijk dataset
      gemeente: "data/merged_data_reprojected_GM_1.geojson"  // Gemeente dataset
    };
    let currentLayer;
    const color = d3.scaleOrdinal(d3.schemeCategory10); // Distinct colors per cluster


    let factor_watch_list = [];
    let collumns_file = [];

    let new_factors = true;
    let newGranularity = "gemeente";
    const column_descriptions = {
      "a_inw": "Number of inhabitants",
      "a_man": "Number of male inhabitants",
      "a_vrouw": "Number of female inhabitants",
      "a_00_14": "Number of inhabitants aged 0 to 14 years",
      "a_15_24": "Number of inhabitants aged 15 to 24 years",
      "a_25_44": "Number of inhabitants aged 25 to 44 years",
      "a_45_64": "Number of inhabitants aged 45 to 64 years",
      "a_65_oo": "Number of inhabitants aged 65 years or older",
      "a_ongeh": "Number of unmarried individuals",
      "a_gehuwd": "Number of married individuals",
      "a_gesch": "Number of divorced individuals",
      "a_verwed": "Number of widowed individuals",
      "a_w_all": "Western migration background total",
      "a_nw_all": "Non-Western migration background total",
      "a_marok": "Migration background: Morocco",
      "a_antaru": "Migration background: Netherlands Antilles and Aruba",
      "a_suri": "Migration background: Suriname",
      "a_tur": "Migration background: Turkey",
      "a_ov_nw": "Migration background: Other non-Western countries",
      "a_geb": "Total births",
      "p_geb": "Birth rate per 1,000 inhabitants",
      "a_ste": "Total deaths",
      "p_ste": "Mortality rate per 1,000 inhabitants",
      "a_hh": "Total number of households",
      "a_1p_hh": "Number of single-person households",
      "a_hh_z_k": "Households without children",
      "a_hh_m_k": "Households with children",
      "g_hhgro": "Average household size",
      "bev_dich": "Population density (inhabitants per km²)",
      "a_woning": "Total housing stock",
      "g_wozbag": "Average property value (WOZ)",
      "p_1gezw": "Percentage of single-family homes",
      "p_mgezw": "Percentage of multi-family homes",
      "p_bewndw": "Percentage of occupied dwellings",
      "p_leegsw": "Percentage of unoccupied dwellings",
      "p_koopw": "Percentage of owner-occupied homes",
      "p_huurw": "Percentage of rented homes",
      "p_wcorpw": "Percentage of homes owned by housing corporations",
      "p_ov_hw": "Percentage of homes owned by other landlords",
      "p_e_o_w": "Percentage of homes with unknown ownership",
      "p_bjj2k": "Percentage of homes built before 2000",
      "p_bjo2k": "Percentage of homes built from 2000 onwards",
      "g_ele": "Average electricity consumption (total)",
      "g_ele_ap": "Electricity consumption: Apartments",
      "g_ele_tw": "Electricity consumption: Terraced houses",
      "g_ele_hw": "Electricity consumption: Corner houses",
      "g_ele_2w": "Electricity consumption: Semi-detached houses",
      "g_ele_vw": "Electricity consumption: Detached houses",
      "g_ele_hu": "Electricity consumption: Rental homes",
      "g_ele_ko": "Electricity consumption: Owner-occupied homes",
      "g_gas": "Average gas consumption (total)",
      "g_gas_ap": "Gas consumption: Apartments",
      "g_gas_tw": "Gas consumption: Terraced houses",
      "g_gas_hw": "Gas consumption: Corner houses",
      "g_gas_2w": "Gas consumption: Semi-detached houses",
      "g_gas_vw": "Gas consumption: Detached houses",
      "g_gas_hu": "Gas consumption: Rental homes",
      "g_gas_ko": "Gas consumption: Owner-occupied homes",
      "p_stadsv": "Percentage of homes with district heating",
      "ste_mvs": "Degree of urbanization",
      "ste_oad": "Address density",
      "pst_mvp": "Most common postal code",
      "pst_dekp": "Postal code coverage percentage",
      "a_opp_ha": "Total area (hectares)",
      "a_lan_ha": "Land area (hectares)",
      "a_wat_ha": "Water area (hectares)",
      "a_opl_lg": "Low education level population",
      "a_opl_md": "Medium education level population",
      "a_opl_hg": "High education level population",
      "p_arb_pp": "Net labor participation rate",
      "p_arb_wn": "Percentage of employees",
      "p_arb_zs": "Percentage of self-employed individuals",
      "a_inkont": "Number of income recipients",
      "g_ink_po": "Average income per recipient",
      "g_ink_pi": "Average income per inhabitant",
      "p_ink_li": "40% of population with lowest income",
      "p_ink_hi": "20% of population with highest income",
      "g_hh_sti": "Standardized household income",
      "p_hh_li": "40% of households with lowest income",
      "p_hh_hi": "20% of households with highest income",
      "p_hh_osm": "Household below or around the social minimum",
      "m_hh_ver": "Median wealth of households",
      "a_soz_wb": "Social assistance benefits recipients",
      "a_soz_ao": "Disability benefits recipients",
      "a_soz_ww": "Unemployment benefits recipients",
      "a_soz_ow": "Old-age benefits recipients",
      "a_jz_tn": "Youth care recipients",
      "p_jz_tn": "Percentage of youth care recipients",
      "a_wmo_t": "Social support clients",
      "p_wmo_t": "Social support clients per 1,000 inhabitants",
      "a_bedv": "Total business establishments",
      "a_bed_a": "Business establishments: Agriculture, forestry, and fishing",
      "a_bed_bf": "Business establishments: Industry and energy",
      "a_bed_gi": "Business establishments: Trade and hospitality",
      "a_bed_hj": "Business establishments: Transport, information, and communication",
      "a_bed_kl": "Business establishments: Financial services and real estate",
      "a_bed_mn": "Business establishments: Business services",
      "a_bed_ru": "Business establishments: Culture, recreation, and other services",
      "a_pau": "Total passenger cars",
      "a_bst_b": "Passenger cars: Petrol",
      "a_bst_nb": "Passenger cars: Other fuels",
      "g_pau_hh": "Passenger cars per household",
      "g_pau_km": "Passenger cars per km²",
      "a_m2w": "Motorcycles",
      "g_afs_hp": "Distance to general practitioner",
      "g_afs_gs": "Distance to large supermarket",
      "g_afs_kv": "Distance to daycare center",
      "g_afs_sc": "Distance to school",
      "g_3km_sc": "Number of schools within 3 km",
    }
    const linePaths = {};
    const descriptions = Object.values(column_descriptions);

    // Initial Map Load
    loadData();
    updateFactorList();

    // Initial load
    loadLineChart();
    

// Load data needed for the symbol map: geographical data and parts of the clusterdata. Then, start function for rendering the map     
function loadData() { 
      
    // load GeoJSON data for all granularities
      const GeoPromises = [ // use this promise-constant to make sure the next function is not called when the data isn't loaded yet
        d3.json("data/merged_data_reprojected_GM_1.geojson").then(GeoDataGemeente => { // fetch the GeoJSON file for the granularity 'municipality' and place it in the GeoPromises array
          console.log(`Loaded GeoJSON Data (gemeente)`);
          return GeoDataGemeente; 
        }).catch(error => {
          console.error(`Error loading GeoJSON data (gemeente):`, error);
        }), 
        
        d3.json("data/merged_data_reprojected_WK_1.geojson").then(GeoDataWijk => { // fetch the GeoJSON file for the granularity 'wijk' and place it in the GeoPromises array
          console.log(`Loaded GeoJSON Data (wijk)`);
          return GeoDataWijk; 
        }).catch(error => {
          console.error(`Error loading GeoJSON data (wijk):`, error);
        }),     
        
        Promise.all([ // fetch GeoJSON file (wihch is divided over 2 files) for the granularity 'buurt' and place it in the GeoPromises array
            d3.json("data/merged_data_part1_1.geojson"),
            d3.json("data/merged_data_part2_1.geojson")
          ])
          .then(([geoDataPart1, geoDataPart2]) => { // Combine both parts horizontally
            const GeoDataBuurt = {
              type: "FeatureCollection", // collection of geographical features
              features: [...geoDataPart1.features, ...geoDataPart2.features] // extract features from the two geojson files and combine into a single array
            };
            console.log(`Loaded GeoJSON Data (buurt)`);
            return GeoDataBuurt; 
          }).catch(error => {
            console.error(`Error loading GeoJSON data (buurt):`, error);
          })      
      ];

    // load the cluster files and create a map where region ID is coupled to cluster number (perhaps the mapping is not necessary and the data file can be used directly)
      const granularities = ["buurt", "wijk", "gemeente"]; // granularities to iterate over
      const clusterFiles = {buurt: "data/clustered_BU.csv", // cluster file per granularity
                            wijk: "data/clustered_WK.csv",
                            gemeente: "data/clustered_GM.csv"};

      let clusterMapGemeente = {}; // variables to store the clustermaps in
      let clusterMapWijk = {};
      let clusterMapBuurt = {};

      const clusterPromises = granularities.map(granularity => { // use this promise-constant to make sure the next function is not called when the data isn't loaded yet
        const clusterFile = clusterFiles[granularity]; //get the cluster file
        return d3.csv(clusterFile).then(clusterData => {            
          const clusterMap = {}; //create a map where region ID is coupled to cluster number 
          clusterData.forEach(row => {
            if (row.ID && row.cluster) { 
              clusterMap[row.ID.trim()] = row.cluster.trim(); // Normalize both ID and cluster
            }
          });
          console.log(`Created Cluster Map (${granularity})`); 
          
          if (granularity === "buurt") { //store the clustermap in the correct variable
              clusterMapBuurt = clusterMap;
          } else if (granularity === "wijk") {
              clusterMapWijk = clusterMap;
          } else if (granularity === "gemeente") {
              clusterMapGemeente = clusterMap;
          }
        }).catch(error => {
          console.error(`error loading clustered CSV data for ${granularity}:`, error); 
        });
      });

      //make sure all data is loaded before starting the next function 
      Promise.all([...GeoPromises, ...clusterPromises]).then(results => {
        const [GeoDataGemeente, GeoDataWijk, GeoDataBuurt] = results.slice(0,3); //gives the loaded geo data the correct names

        // Call the next function with all the loaded data
        renderMap(GeoDataGemeente, GeoDataWijk, GeoDataBuurt, clusterMapGemeente, clusterMapWijk, clusterMapBuurt);
    }).catch(error => {
        console.error("Error loading all data:", error);
    });
}

// render the geographical/symbol map
function renderMap(GeoDataGemeente, GeoDataWijk, GeoDataBuurt, clusterMapGemeente, clusterMapWijk, clusterMapBuurt) {
      console.log("started rendering the map"); 
      
      //settings
      const width = 600, height = 525; //map dimensions
      const zoomThreshold1 = 5; // level of zoom at which the map changes granularity from municipality to district
      const zoomThreshold2 = 15; // level of zoom at which the map changes granularity from district to neighborhood
      const radius = 3; // circle radius
      //const clusterColors = d3.scaleOrdinal(d3.schemeCategory10); // circle colors (identical to those in the line chart) 

      const projection = d3.geoMercator() //set up map projection 
                           .center([5.5, 52])
                           .scale(5000)
                           .translate([width / 2, height / 2]);

      const path = d3.geoPath().projection(projection); //transform geojson data into a path that can be rendered 

      const geoMap = d3.select("#geo-map"); //selects the html-container for the map
      geoMap.selectAll("*").remove(); // Clear previous map
  
      const svg = geoMap.append("svg") //create SVG element
                        .attr("width", width)
                        .attr("height", height)

      //zoom behaviour 
      const g = svg.append("g"); //create a group for zooming
  
      let prevZoomLevel = 1; //to track the previous zoom level
      
      function throttle(func, limit) { //to limit how often the zoom handler runs: reduce CPU load and improve responsiveness
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
  
      const zoom = d3.zoom()
                     .scaleExtent([1, 30]) // Limit zoom scale 
                     .translateExtent([[0, 0], [width, height]]) // Limit pan (ensure pan does not go out of bounds)
                     .on("zoom", throttle((event) => { // work via throttle to reduce CPU load
                       const zoomLevel = event.transform.k;
                       
                       g.attr("transform", event.transform); //zoom
                       g.selectAll("path").attr("stroke-width", 1 / event.transform.k); // keep line width constant
                       g.selectAll("circle").attr("r", radius / event.transform.k); // keep circle radius constant

                       if ((prevZoomLevel < zoomThreshold1 && zoomLevel >= zoomThreshold1) || (prevZoomLevel >= zoomThreshold1 && zoomLevel < zoomThreshold1)) { //when the zoomlevel increases or decreases past the first zoom threshold the shown layer is updated
                        if(zoomLevel < zoomThreshold1){
                          showLayer("municipality");
                          newGranularity = "gemeente"; 
                        } else {
                          showLayer("district");
                          newGranularity = "wijk"; 
                        }
                        //showLayer(zoomLevel < zoomThreshold1 ? "municipality" : "district"); // if zoom is below the threshold, the municipality layer is shown, otherwise the district layer
                       } else if ((prevZoomLevel < zoomThreshold2 && zoomLevel >= zoomThreshold2) || (prevZoomLevel >= zoomThreshold2 && zoomLevel < zoomThreshold2)) { //when the zoomlevel increases or decreases past the second zoom threshold the shown layer is updated
                          //showLayer(zoomLevel < zoomThreshold2 ? "district" : "neighborhood"); // if zoom is below the threshold, the district layer is shown, otherwise the neighborhood layer
                          if(zoomLevel < zoomThreshold2){
                            showLayer("district");
                            newGranularity = "wijk"; 
                          } else {
                            showLayer("neighborhood");
                            newGranularity = "buurt"; 
                          }
                        }

                       //update the state variable, and calls the update of the line chart
                       if (state.granularity !== newGranularity) {
                            state.granularity = newGranularity;
                            new_factors = true;
                            if (newGranularity == "gemeente") {
                              state.city = "GM0014";
                            }
                            else if (newGranularity == "wijk") {
                              state.city = "WK001400";
                            }
                            else {
                              state.city = "BU00140000";
                            }
                            updateFactorList();
                            updateLineChart(); // Synchronize the line chart with the map
                        }
                       prevZoomLevel = zoomLevel;
                     }, 50)); //throttle limit
  
      svg.call(zoom); //apply zoom behaviour to the svg

      function showLayer(layerName) { //show a layer
        g.selectAll(".layer").style("display", "none"); //make sure none are visible
        g.select(`.layer.${layerName}`).style("display", "block"); //show the correct layer
        const selectedLayer = g.select(`.layer.${layerName}`);
        selectedLayer.style("display", "block");
        currentLayer = layers.find(layer => layer.name === layerName);
        
        console.log(`Switched to layer: ${layerName}`);
      }
  
      //create groups within the g-group which will function as layers for the different granularities
      const layer_GM = g.append("g").attr("class", "layer municipality"); //create a group for the municipality layer, and assign the class names layer and municipality
      const layer_WK = g.append("g").attr("class", "layer district"); //create a group for the district layer, and assign the class names layer and district
      const layer_BU = g.append("g").attr("class", "layer neighborhood"); //create a group for the district layer, and assign the class names layer and district       
  
      //define the information belonging to each layer
      const layers = [{ name: "municipality", data: GeoDataGemeente, clusterMap: clusterMapGemeente, idKey: "gm_code", layerGroup: layer_GM },
                      { name: "district", data: GeoDataWijk, clusterMap: clusterMapWijk, idKey: "wk_code", layerGroup: layer_WK },
                      { name: "neighborhood", data: GeoDataBuurt, clusterMap: clusterMapBuurt, idKey: "geo_ID", layerGroup: layer_BU }];
      console.log("Defined layer information: ", layers);  
  
      //iterate to render the paths/circles belonging to each layer
      layers.forEach(layer => { 
        console.log(`iteration: layer ${layer.name}`); 
        if (!layer.data || !layer.data.features) {
            console.warn(`Layer ${layer.name} has no valid data.`);
            return;
        }

        const layerGroup = layer.layerGroup; // retrieve the correct layer-group
        
        //add paths
        layerGroup.selectAll("path") 
                  .data(layer.data.features)
                  .join("path")
                  .attr("d", path)
                  .attr("fill", "#e0e0e0") //fill color of the map
                  .attr("stroke", "#333") //stroke color of the map
                  .on("mouseover", (event, d) => {
    const regionId = d.properties[layer.idKey];
    const cluster = layer.clusterMap[regionId]?.trim();
    const lbmValues = d.properties;
    console.log("Circle mouseover triggered");
    
    const tooltipContent = `
      <strong>Region ID:</strong> ${regionId}<br>
      <strong>LBM Values:</strong> ${JSON.stringify(lbmValues, null, 2)}<br>
      <strong>Cluster:</strong> ${cluster || "Unknown"}
    `;

    d3.select("#tooltip")
      .html(tooltipContent)
      .style("left", `${event.pageX}px`)
      .style("top", `${event.pageY}px`)
      .style("display", "block")
      .style("position", "fixed")
      .style("background", "white")
      .style("border", "1px solid black")
      .style("padding", "10px")
      .style("z-index", "9999");


  })
  .on("mouseout", () => {
    d3.select("#tooltip").style("display", "none");
    // Reset cluster highlighting
    Object.values(linePaths).forEach(path => {
      path.attr("stroke-width", 2).attr("opacity", 1);
    });
  });
        //add circles
        layer.data.features.forEach(d => { //cache the centroids so they don't have to be recalculated every time (perhaps move thise to outside the layers-iteration, if this works with zoom)
          d.centroid = path.centroid(d);
        });
        
        layerGroup.selectAll("circle") 
                  .data(layer.data.features)
                  .join("circle")
                  .attr("cx", d => d.centroid[0]) //extract the x-coordinate of the center of the geojson polygon data
                  .attr("cy", d => d.centroid[1]) //extract the y-coordinate of the center of the geojson polygon data
                  .attr("r", radius)
                  .attr("fill", d => {
                    const regionId = d.properties[layer.idKey]; // Match region ID from GeoJSON
                    const cluster = layer.clusterMap[regionId];   // Get cluster number from CSV
                    return cluster !== undefined ? color(cluster) : "#ccc"; // Assign color based on cluster
                  })
                  .on("mouseover", (event, d) => {
    const regionId = d.properties[layer.idKey];
    const cluster = layer.clusterMap[regionId]?.trim();
    const lbmValues = d.properties;
    console.log("Circle mouseover triggered");

    // Move tooltip div outside scatter plot container
document.querySelector(".chart-container").insertAdjacentHTML('beforeend', `
  <div id="tooltip" style="
    position: fixed;
    display: none;
    background: white;
    border: 1px solid #000;
    padding: 10px;
    z-index: 9999;
    pointer-events: none;
  "></div>
`);

    const tooltipContent = `
      <strong>Region ID:</strong> ${regionId}<br>
      <strong>LBM Values:</strong> ${JSON.stringify(lbmValues, null, 2)}<br>
      <strong>Cluster:</strong> ${cluster || "Unknown"}
    `;

    d3.select("#tooltip")
      .html(tooltipContent)
      .style("left", `${event.pageX}px`)
      .style("top", `${event.pageY}px`)
      .style("display", "block")
      .style("position", "fixed")
      .style("background", "white")
      .style("border", "1px solid black")
      .style("padding", "10px")
      .style("z-index", "9999");

  })
  .on("mouseout", () => {
    d3.select("#tooltip").style("display", "none");
    // Reset cluster highlighting
    Object.values(linePaths).forEach(path => {
      path.attr("stroke-width", 2).attr("opacity", 1);
    });
  })
  .on("click", (event, d) => {
    const regionId = d.properties[layer.idKey];
    const cluster = layer.clusterMap[regionId]?.trim();
    if (cluster !== undefined && cluster !== null) {
      highlightCluster(cluster);
    }
    if (regionId !== undefined && regionId !== null) {
      state.city = regionId;
      updateFactorList();
    }
  });
      });
  
      console.log("Rendering iterations finished"); 
      showLayer("municipality");
  
      geoMap.style("overflow", "hidden"); //ensure the map does not zoom outside of its container

    }

//create the line chart
function loadLineChart() {
  
    let clusterFile;

    if (state.granularity === "buurt") {
      clusterFile = "data/clustered_BU.csv";
    } else if (state.granularity === "wijk") {
      clusterFile = "data/clustered_WK.csv";
    } else {
      clusterFile = "data/clustered_GM.csv";
    }
  
    d3.csv(clusterFile).then(data => {
      console.log("line chart cluster data loaded"); 
      //console.log("Cluster Data Loaded:", data);

    // Extract years and scores
    const years = [2002, 2008, 2012, 2014, 2016, 2018, 2020, 2022];

    // Organize data by cluster
    const clusters = d3.group(data, d => d.cluster);

    // Create Line Chart
    // Create Line Chart
    const lineGraph = d3.select("#line-graph");
    lineGraph.selectAll("*").remove(); // Remove all previous elements
    const lineSvg = lineGraph.append("svg")
    .attr("width", 600)
    .attr("height", 500);

    const margin = { top: 20, right: 20, bottom: 50, left: 50 };
    const width = 600 - margin.left - margin.right;
    const height = 480 - margin.top - margin.bottom;

    const g = lineSvg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const x = d3.scalePoint()
      .domain(years)
      .range([0, width]);

    const y = d3.scaleLinear()
      .domain([3.8, 4.5]) // Adjust domain based on expected LBM scores 
      .range([height, 0]);

    // Axes
    g.append("g")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x));

    g.append("g")
      .call(d3.axisLeft(y));

    // Line generator
    const line = d3.line()
      .x(d => x(d.year))
      .y(d => y(d.score));

    // Create an empty object to store line paths
    //const linePaths = {};

    // Add lines for each cluster
    //const color = d3.scaleOrdinal(d3.schemeCategory10); // Distinct colors per cluster

    clusters.forEach((clusterData, clusterId) => {
      const avgScores = years.map(year => {
        const clusterScores = clusterData.map(d => +d[`lbm_${year}`]);
        return {
          year: year,
          score: d3.mean(clusterScores.filter(d => !isNaN(d)))
        };
      });
      const normalizedClusterId = clusterId?.trim();
      // Draw the line and store the path in linePaths
      const path = g.append("path")
        .datum(avgScores)
        .attr("fill", "none")
        .attr("stroke", color(normalizedClusterId))
        .attr("stroke-width", 2)
        .attr("d", line)
        .on("click", () => {
          highlightMapPoints(normalizedClusterId, currentLayer); // Call map highlight function
        });

      // Store the path for later use
      linePaths[normalizedClusterId] = path;
    });

    // Add labels
    g.append("text")
      .attr("x", width / 2)
      .attr("y", -5)
      .attr("text-anchor", "middle")
      .attr("font-size", "16px")
      .text("Average LBM Scores Per Cluster Over Time");

    g.append("text")
      .attr("x", -height / 2)
      .attr("y", -35)
      .attr("transform", "rotate(-90)")
      .attr("text-anchor", "middle")
      .attr("font-size", "12px")
      .text("Average LBM Score");

    g.append("text")
      .attr("x", width / 2)
      .attr("y", height + 40)
      .attr("text-anchor", "middle")
      .attr("font-size", "12px")
      .text("Years");

    const legendContainer = d3.select("#legend")
      .html("") // Clear any existing legend
      .style("display", "flex")
      .style("justify-content", "center")
      .style("flex-wrap", "wrap")
      .style("gap", "20px")
      .style("margin-top", "20px");

    clusters.forEach((_, clusterId) => {
      const legendItem = legendContainer.append("div")
        .attr("class", "legend-item")
        .style("display", "flex")
        .style("align-items", "center")
        .style("margin", "5px");

      legendItem.append("div")
        .style("width", "20px")
        .style("height", "20px")
        .style("background-color", color(clusterId))
        .style("margin-right", "10px");

      legendItem.append("span")
        .text(`Cluster ${clusterId}`)
        .style("font-size", "12px");

      // Add hover interaction for legend
      legendItem.on("mouseover", function() {
        // Highlight the corresponding line
        linePaths[clusterId].attr("stroke-width", 4).attr("stroke", color(clusterId)); // Change stroke on hover
        }).on("mouseout", function() {
        // Reset the line to its original color and width
        linePaths[clusterId].attr("stroke-width", 2).attr("stroke", color(clusterId)); // Reset the line to the original color
        });
      });

      }).catch(error => {
        console.error("Error loading cluster data:", error);
      });
    }

    function updateLineChart() {
      const granularity = state.granularity;
      loadLineChart();
    }


    function highlightCluster(clusterId) {
      console.log(`Attempting to highlight cluster: ${clusterId}`);

      // Reset all lines to their default style
      Object.values(linePaths).forEach(path => {
        path.attr("stroke-width", 2).attr("opacity", 0.5); // Reset other lines
      });

      // Highlight the selected cluster
      const selectedPath = linePaths[clusterId];
      if (selectedPath) {
        selectedPath.attr("stroke-width", 7).attr("opacity", 1); // Highlight
        console.log(`Highlighted cluster: ${clusterId}`);
      } else {
        console.warn(`No path found for cluster: ${clusterId}`);
      }
    }

    function highlightMapPoints(clusterId, layer) {
      console.log(`Highlighting map points for cluster: ${clusterId}`);

      // Reset styles for all points
      d3.selectAll("#geo-map circle")
        .attr("stroke", null)
        .attr("stroke-width", null)
        .attr("opacity", 0.5);
      console.log(`garnularity: ${state.granularity}`);
      // Highlight points belonging to the clicked cluster
      //const color = d3.scaleOrdinal(d3.schemeCategory10);
      d3.selectAll("#geo-map circle")
        .filter(function (d) {
          const regionId = d.properties[layer.idKey]; // Retrieve region ID based on the layer's idKey
          const cluster = layer.clusterMap[regionId]?.trim(); // Get cluster from clusterMap
          console.log(`Region ID: ${regionId}, Cluster: ${cluster}`);
          console.log(`Region Data:`, d.properties);

          return cluster === clusterId; // Match the cluster ID
        })
        .attr("stroke", color(clusterId)) // Add a highlight stroke
        .attr("stroke-width", 7)
        .attr("opacity", 1); // Ensure visibility
    }

    /*const regionId = d.properties[layer.idKey];
                    const cluster = layer.clusterMap[regionId]?.trim();
                    console.log(`Region ID: ${regionId}, Cluster: ${cluster}`); 
                    console.log(`Cluster retrieved:`, cluster);*/
    // Add an event listener to the map background for resetting styles
   /* d3.select("#geo-map")
        .on("click", function(event) {
          console.log("Map background clicked. Resetting styles.");

          // Reset styles for all points
          d3.selectAll("#geo-map circle")
            .attr("stroke", null)
            .attr("stroke-width", null)
            .attr("opacity", 1);

          // Optionally reset the tooltip or other elements
          //d3.select("#tooltip").style("display", "none");
        });
*/
      // Ensure the click events on circles do not propagate to the background
      d3.selectAll("#geo-map circle")
        .on("click", function(event) {
          event.stopPropagation(); // Prevent event from propagating to the map background
     
        });




    // ----------------------------------------------------
    // ----------------------------------------------------
    // ----------------------------------------------------
    // SECOND VISUALIZATION
    // ----------------------------------------------------
    // ----------------------------------------------------
    // ----------------------------------------------------


    function getCorrelations() {
      return new Promise((resolve, reject) => {
        let final_factors = [];

        if (state.granularity === "buurt") {
          file = `data/2_visualization/Buurt/BU_correlations.csv`;
        } else if (state.granularity === "wijk") {
          file = `data/2_visualization/Wijk/WK_correlations.csv`;
        } else {
          file = `data/2_visualization/Gemeente/GM_correlations.csv`;
        }

        d3.dsv(";", file)
          .then(data => {

            const factorsWithCorrelations = [];

            data.forEach(row => {
              const combinedValue = row["factor,lbm"];

              // Split the string to extract the factor and correlation
              if (combinedValue && combinedValue.includes(',')) {
                const [factor, rawCorrelation] = combinedValue.split(',');

                // Parse the correlation value
                const correlation = parseFloat(rawCorrelation);

                // Check correlation threshold
                if (Math.abs(correlation) > 0.35) {
                  factorsWithCorrelations.push({ factor, correlation });
                }
              }
            });

            // Sort the array by correlation (ascending)
            factorsWithCorrelations.sort((a, b) => a.correlation - b.correlation);

            // Get the 3 lowest and 3 highest correlations
            const lowestFactors = factorsWithCorrelations.slice(0, 3);
            const highestFactors = factorsWithCorrelations.slice(-3);

            lowestFactors.forEach(p => {final_factors.push(p.factor)});
            highestFactors.forEach(p => {final_factors.push(p.factor)});

            resolve(final_factors); // Resolve the Promise with final_factors
          })
          .catch(error => {
            console.error(`Error loading file ${file}:`, error);
            reject(error); // Reject the Promise on error
          });
      });
    }

    function loadScatterData() {

      let file, names_codes;
      const promises = [];
      data_final = {};

      factor_watch_list.forEach(factor => {
        data_final[factor] = {};  // Initialize the factor key in data_final

        if (state.granularity === "buurt") {
          file = `data/2_visualization/Buurt/BU_means.csv`;
          names_codes = "BU_name";
        } else if (state.granularity === "wijk") {
          file = `data/2_visualization/Wijk/WK_means.csv`;
          names_codes = "WK_name";
        } else {
          file = `data/2_visualization/Gemeente/GM_means.csv`;
          names_codes = "GM_name";
        }

        const promise = d3.dsv(";", file).then(data => {

          collumns_file = data["columns"];

          // Initialize the year key in the factor object if it doesn't exist
          data_final[factor] = data.map(row => {

            const factorValue = parseFloat(row[factor].replace(',', '.'));
            const lbmValue = parseFloat(row["lbm"].replace(',', '.'));
            if (!isNaN(factorValue) && !isNaN(lbmValue)) {
                return {
                    code: row["ID"],
                    name: row[names_codes],
                    lbm: lbmValue,
                    factor: factorValue
                };
            }

            // If the factor or lbm is invalid, return null or skip this entry
            return null;
          }).filter(item => item !== null); // Remove null entries if any
        }).catch(error => {
              console.error(`Error loading file ${file}:`, error);
        });

        promises.push(promise);
      });

      Promise.all(promises).then(() => {
          createScatterPlot(data_final);
      });
    } 

    function createScatterPlot(data_org) {
      const width = 300;
      const height = 300;
      const margin = { top: 20, right: 30, bottom: 50, left: 50 };

      // Select the container for all plots
      const plotsContainer = d3.select("#scatter-plot-container");

      // Add a tooltip
      const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("display", "none")
        .style("position", "absolute")
        .style("background", "white")
        .style("border", "1px solid black")
        .style("padding", "3px")
        .style("font-size", "12px")
        .style("pointer-events", "none");

      function mapPointsToContours(data, contours, xScale, yScale) {
        const pointToContourMap = [];

        contours.forEach((contour, contourIndex) => {
          const polygons = contour.coordinates;
          data.forEach((point) => {
            const x = xScale(point.factor);
            const y = yScale(point.lbm);
            polygons.forEach((polygon) => {
              if (d3.polygonContains(polygon[0], [x, y])) {
                pointToContourMap.push({ point, contourIndex, density: contour.value });
              }
            });
          });
        });

        return pointToContourMap;
      }

      Object.keys(data_org).forEach((factorKey) => {
        const data = data_org[factorKey];
        const highlightData = data.find(d => d.code === state.city);
  
        
        const container = plotsContainer
          .append("div")
          .attr("class", "scatter-plot-container")
          .style("width", `${width + margin.left + margin.right}px`)
          .style("height", `${height + margin.top + margin.bottom + 60}px`)
          .style("background-color", "#fff");
          

        
        container.append("h4").text(`${column_descriptions[factorKey]}`);
        // Highlight the factors with the biggest potential i.e. the ones that differ 20 % of the mean
        if (highlightData) {
    
          const averageValue = d3.mean(data, d => d.factor);
          
          if (highlightData.factor > averageValue * 1.2) {
       
            container.style("box-shadow", "0 0 15px 5px rgba(255, 0, 0, 0.5)");
          } else if (highlightData.factor < averageValue * 0.8) {
            
            container.style("box-shadow", "0 0 15px 5px rgba(0, 0, 255, 0.5)");

  }
}

        const svg = container
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const xScale = d3.scaleLinear()
          .domain(d3.extent(data, (d) => d.factor))
          .range([0, width]);

        const yScale = d3.scaleLinear()
          .domain(d3.extent(data, (d) => d.lbm))
          .range([height, 0]);

        const density = d3.contourDensity()
          .x((d) => xScale(d.factor))
          .y((d) => yScale(d.lbm))
          .size([width, height])
          .bandwidth(20)(data);

        const densityValues = density.map(d => d.value);
        const minDensity = d3.min(densityValues);
        const maxDensity = d3.max(densityValues);

        const colorScale = d3.scaleSequential(d3.interpolateViridis)
          .domain([minDensity, maxDensity]);

        const pointToContourMap = mapPointsToContours(data, density, xScale, yScale);

        svg.selectAll("path")
          .data(density)
          .enter()
          .append("path")
          .attr("d", d3.geoPath())
          .attr("fill", (d) => colorScale(d.value))
          .attr("stroke", "none")
          .on("mouseover", (event, d) => {
            const pointsInRegion = pointToContourMap.filter(entry => entry.density === d.value);

            svg.selectAll("circle")
              .attr("stroke", "none")
              .attr("opacity", 0.3);

            pointsInRegion.forEach(({ point }) => {
              svg.append("circle")
                .attr("cx", xScale(point.factor))
                .attr("cy", yScale(point.lbm))
                .attr("r", 5)
                .attr("fill", "red")
                .attr("stroke", "black");
            });
          })
          .on("mousemove", (event) => {
            tooltip.style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 10}px`);
            ;
          })
          .on("mouseout", () => {
            tooltip.style("display", "none");
            svg.selectAll("circle").remove();
            const highlightData = data.find(d => d.code === state.city);

            if (highlightData) {
              svg.append("circle")
                .attr("cx", xScale(highlightData.factor))
                .attr("cy", yScale(highlightData.lbm))
                .attr("r", 5)
                .attr("fill", "orange")
                .attr("stroke", "black")
                .on("mouseover", (event) => {
                  tooltip.style("display", "block")
                    .html(`Name: ${highlightData.name}<br>LBM: ${highlightData.lbm}<br>${column_descriptions[factorKey]}: ${highlightData.factor}`);
                })
                .on("mousemove", (event) => {
                  
                  tooltip.style("left", `${event.pageX + 10}px`)
                    .style("top", `${event.pageY - 20}px`);
                })
                .on("mouseout", () => {
                  tooltip.style("display", "none");
                });
            }
          });

        const xAxis = d3.axisBottom(xScale).ticks(5).tickFormat(d3.format(".2f"));
        const yAxis = d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".2f"));

        svg.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(xAxis)
          .append("text")
          .attr("fill", "black")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("text-anchor", "middle")
          .text(descriptions[factorKey]);

        svg.append("g")
          .call(yAxis)
          .append("text")
          .attr("fill", "black")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -40)
          .attr("text-anchor", "middle")
          .text("LBM");

        if (state.city) {
          const highlightData = data.find(d => d.code === state.city);
          const selectedCity = d3.select("#selected-city");
          selectedCity.text(highlightData.name);

          if (highlightData) {
            svg.append("circle")
              .attr("cx", xScale(highlightData.factor))
              .attr("cy", yScale(highlightData.lbm))
              .attr("r", 5)
              .attr("fill", "orange")
              .attr("stroke", "black")
              .on("mouseover", (event) => {
                tooltip.style("display", "block")
                  .html(`Name: ${highlightData.name}<br>LBM: ${highlightData.lbm}<br>${factorKey}: ${highlightData.factor}`);
              })
              .on("mousemove", (event) => {
                tooltip.style("left", `${event.pageX + 10}px`)
                  .style("top", `${event.pageY - 20}px`);
              })
              .on("mouseout", () => {
                tooltip.style("display", "none");
              });
          }       
        }
      });
    }



    // Search functionality
    const searchInput = document.getElementById("factor-search");
    const suggestionsBox = document.getElementById("suggestions");
    searchInput.addEventListener("input", seeSuggestions);

    function seeSuggestions() {


      const query = searchInput.value.trim().toLowerCase();
      suggestionsBox.innerHTML = ""; // Clear current suggestions
      if (query) {

        const matches = Object.entries(column_descriptions).filter(([, value]) =>
          value.toLowerCase().includes(query)
        );


        matches.forEach(([key, value]) => {

          const suggestionItem = document.createElement("div");
          suggestionItem.textContent = `${value}`;
          suggestionItem.classList.add("suggestion-item");

          suggestionItem.addEventListener("click", () => {
            searchInput.value = suggestionItem.textContent;
            suggestionsBox.style.display = 'none';
          });


          suggestionsBox.appendChild(suggestionItem);

        });

        suggestionsBox.style.display = 'block';

      }
    }


    function findKeyByValue(dictionary, targetValue) {
      return Object.keys(dictionary).find(key => dictionary[key] === targetValue) || null;
    }

    const addButton = document.getElementById('add-button');
    addButton.addEventListener('click', addFactorToPlots);

    async function addFactorToPlots() {

      try {
        const match = await findKeyByValue(column_descriptions, searchInput.value)

        if (match) {
          if (factor_watch_list.includes(match)) {
            alert("Factor is already on the list");
          } else {
            if (collumns_file.includes(match)) {
              factor_watch_list.push(match);
              updateFactorList();
            }
            else {
              alert("The current granularity level does not have this factor");
            }
          }    
          searchInput.value = "";  
        }
      }
      catch (error) {
        console.error("Error updating factor list:", error);
      }
    }

    async function updateFactorList() {
      const factorList = document.getElementById("factor-list");
      factorList.innerHTML = ""; // Clear the current list

      d3.select("#scatter-plot-container").html(""); // Clear the container
      data_final = {};

      try {

        if (new_factors) {
          factor_watch_list = await getCorrelations(); // Wait for getCorrelations to complete
        }

        new_factors = false;
        loadScatterData();

        factor_watch_list.forEach(factor => {
          const li = document.createElement("li");
          li.textContent = `${column_descriptions[factor]}`;

          const removeButton = document.createElement("span");
          removeButton.textContent = " ×";
          removeButton.style.color = "red";
          removeButton.style.cursor = "pointer";
          removeButton.style.marginLeft = "10px";

          // Add event listener to remove the factor
          removeButton.addEventListener("click", () => {
            factor_watch_list.splice(factor_watch_list.indexOf(factor), 1); // Remove the factor
            updateFactorList(); // Update the displayed list
          });

          li.appendChild(removeButton);
          factorList.appendChild(li);
        });
      } catch (error) {
        console.error("Error updating factor list:", error);
      }
    }


    document.addEventListener("click", (e) => {
      if (!e.target.closest(".search-container")) {
        suggestionsBox.innerHTML = "";
      }
    });

  </script>
  <div class="container">
    <h1>Quiz Title</h1>
    <div id="progress-bar-container">
        <div id="progress-bar"></div>
    </div>
    <div id="quiz-container"></div>
    <button id="next-button">Next Question</button>
    <div id="result-container" style="display: none;"></div>
  </div>

  <script src="script.js"></script>
</body>

</html>
