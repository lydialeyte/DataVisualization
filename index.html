<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="keywords" content="livability, netherlands, wealth, moving, internationality">
  <meta name="author" content="Group 2">
  <title>Livability in the Netherlands</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>
  <link rel="stylesheet" href="scrolly.css">
</head>

<body id="home">
  <header>
    <h1>Livability in the Netherlands</h1>
    <p>Exploring socioeconomic and geospatial accessibility metrics that influence livability scores in the Netherlands</p>
  </header>

  <section class="introduction">
    <p>
      What makes a place truly livable? Livability encompasses various dimensions of quality of life—ranging from access to amenities and public services to social and environmental factors. Understanding these metrics is crucial as they affect not only where people choose to live but also the overall well-being of communities.

This interactive tool allows you to dive deep into livability trends for your region of interest. You can explore data at three levels—municipalities, districts, and neighborhoods—offering flexibility in analysis. Compare up to five regions of the same type to uncover meaningful differences and similarities.

Once you've gained insight into livability patterns, proceed to examine how socioeconomic and geospatial factors—like income levels, housing, and proximity to green spaces—contribute to these scores. By identifying key areas for improvement, you can help pave the way toward creating more vibrant, sustainable, and equitable communities.
    </p>
    
  </section>
  
  <section class="controls-container" >
    <p>
      Use the interactive tools below to explore livability trends across the Netherlands. The map lets you locate your region of interest and select it directly, or you can search for a specific region using the search bar. Once you’ve selected your region, you can compare it with other regions of the same granularity (municipality, district, or neighborhood) to better understand how they stack up in terms of livability scores.

      On the left, you’ll find a line graph that illustrates the standardized livability trends over time for your selected region and its comparisons. This visualization helps you identify long-term patterns and clusters of regions with similar trajectories.

      To the right is the geographic map, where regions are color-coded by cluster. These clusters group regions based on their livability trends, allowing you to easily spot similarities or outliers. Hover over regions on the map for more details, such as the specific cluster they belong to or other regional information.
    </p>
  </section>
  
  <div class="chart-container">
    <div id="line-graph" class="chart"></div> <!-- Placeholder for the Line Graph -->
    <div id="geo-map" class="chart" style="z-index: 50;">  <!-- Placeholder for the Geographic Map -->
      <div id="tooltip" style="position: absolute; z-index: 1000; display: none; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; padding: 10px; font-size: 12px; pointer-events: none;"></div>
      <div id="loading-icon"> <!-- Placeholder for Loading Icon -->
        <div class="spinner"></div>  
      </div> 
      <div id="granularity-display" style="z-index: 9999;">
        Granularity: Municipality
      </div>
    </div>
  </div>
  
  <div class="chart-container">
  <div id="legend" class="legend-container"></div>
   </div>
   <section class="explanation">
    <p>To help discover patterns in livability, all regions are grouped into clusters based on how their livability scores have changed over time. The clustering algorithm focuses on year-to-year differences, capturing the dynamic changes in livability rather than static values. This ensures that regions with similar trends—whether improving, declining, or stable—are grouped together.

      Each cluster is represented by a standardized cumulative trend line, which shows how regions in the cluster are evolving relative to their average trends over the years. By examining these trend lines, you can identify whether certain clusters are improving rapidly, experiencing declines, or showing consistent stability.
      
      On the geographic map, regions are color-coded by cluster, making it easy to see which regions share similar trajectories. You can hover over any region to reveal additional details, such as its cluster number and other key metrics. This map provides a spatial context to the data, allowing you to visually compare your region of interest with others and explore patterns that emerge across the Netherlands.</p>
    
  </section>
  
  <section class="explanation">
    <p>All regions are grouped into clusters based on the patterns of their livability scores over time. The line graph on the left displays the average livability scores for each cluster. </p>
    <p>On the geographical map, regions are color-coded according to their cluster, allowing you to identify your region's cluster and compare it with others. </p>
  </section>
  
  <section class="introduction">
  <section class="controls-container" >
    <div id="description-container" style="padding: 20px; font-size: 16px; line-height: 1.5;">
      <h3>Analyse the factors that influence the livability</h3>
      <p>
        In the following scatterplots you can identify the factors which have the biggest impact on the livability and can compare
        the values of the factors of the area of your interest to other selected areas.
      </p>
      <p>
        ⁠By default, the 3 factors with the highest positive and negative correlation with the livability score are displayed. 
  
        Of course, you can add factors you are interested in into the analysis or delete them.
      </p>
      <p>
        Have fun exploring the influences of the different factors!
      </p>
    
  <h3 >Add the factors of your interest:</h3>
   <div id="dropdown-container"></div>
   <section id="factor-list-container" class="factor-list-container" style="display: flex; align-items: flex-start;">
    <div id="factor-list-side" class="factor-list-side">
    
      <h3 style="padding-left:50px;">Selected Factors:</h3>
      <ul style="padding-left:60px;"id="factor-list"></ul>
    </div>
    <div id="selected-city-side" class="selected-city-side">
      <h3>Selected Cities: <span id="selected-city">No city selected</span></h3>
      <div id="city-list"></div>
    </div>
  </section>
  <div id="cluster-buttons-container">
    <button id="cluster-button-0" class="cluster-button-0" onclick="handleClusterButtonClick('0')">Cluster 0</button>
    <button id="cluster-button-1" class="cluster-button-1" onclick="handleClusterButtonClick('1')">Cluster 1</button>
    <button id="cluster-button-2" class="cluster-button-2" onclick="handleClusterButtonClick('2')">Cluster 2</button>
    <button id="cluster-button-3" class="cluster-button-3" onclick="handleClusterButtonClick('3')">Cluster 3</button>
    <button id="cluster-button-4" class="cluster-button-4" onclick="handleClusterButtonClick('4')">Cluster 4</button>
  </div>
  <section id="factor-list-container" class="factor-list-container" style="display: flex; align-items: flex-start;"></section>
  <div style="display: flex; align-items: center; gap: 5px;padding-left: 20px">
    <p style="margin: 0;padding-left: 0;">If the absolute correlation of a factor is high and the factor´s value of your favorite selected area is significantly below or above average, it is highlighted with the shadow around the density plot. This indicates that there is potential for improvement; thus, it is especially interesting for you if you want to know how to improve the livability score. </p>
  </div>
  <section id="factor-list-container" class="factor-list-container" style="display: flex; align-items: flex-start;">
    <div style="display: flex; align-items: center; gap: 5px;padding-left: 20px">
      <p style="margin: 0;padding-left: 0;">To improve the livability score of the favorite area of interest especially the factors highlighted with</p>
      <div style="width: 10px; height: 10px; background-color:#fcfbfc; box-shadow: 0 0 10px 2px rgba(228, 0,0, 0.8);"></div>
      <p style="margin: 0;padding-left: 0;">should be decreased and the factors hightlighted with</p>
      <div style="width: 10px; height: 10px; background-color: #fcfbfc; box-shadow: 0 0 10px 2px rgba(0, 0, 228, 0.8);padding-right: 0;"></div>
      <p style="margin: 0;padding-left: 0;">should be increased.</p>
    </div>
  </div>
    <div id="scatter-plot-container"></div>
  </section>
</section>
  
  

  <script>
    // State Configurations    
    const state = { //default configuration of the application 
      year: 2020,
      city: [],
      city_codes: [],
      clusters_watching: [],
      cluster_buttons_clicked: [],  
      favorite: null,
      granularity: "gemeente" // Default granularity
    };

    // data set paths for geographic maps 
    const datasets = {
      buurt: "data/simplified_file.geojson", // Buurt dataset (dummy)
      wijk: "data/merged_data_reprojected_WK_1.geojson",  // Wijk dataset
      gemeente: "data/merged_data_reprojected_GM_1.geojson"  // Gemeente dataset
    };
    let currentLayer;
    const color = d3.scaleOrdinal(d3.schemeCategory10); // Distinct colors per cluster


    let factor_watch_list = [];
    let correlationMap = {};
    let allCorrelations = [];
    let collumns_file = [];

    let new_factors = true;
    let newGranularity = "gemeente";
    const column_descriptions = {
      "a_inw": "Number of inhabitants",
      "a_man": "Number of male inhabitants",
      "a_vrouw": "Number of female inhabitants",
      "a_ongeh": "Number of unmarried individuals",
      "a_gehuwd": "Number of married individuals",
      "a_gesch": "Number of divorced individuals",
      "a_w_all": "Western migration background total",
      "a_nw_all": "Non-Western migration background total",
      "a_ov_nw": "Migration background: Other non-Western countries",
      "a_geb": "Total births",
      "p_geb": "Birth rate per 1,000 inhabitants",
      "a_ste": "Total deaths",
      "p_ste": "Mortality rate per 1,000 inhabitants",
      "a_hh": "Total number of households",
      "g_hhgro": "Average household size",
      "bev_dich": "Population density (inhabitants per km²)",
      "a_woning": "Total housing stock",
      "p_1gezw": "Percentage of single-family homes",
      "p_mgezw": "Percentage of multi-family homes",
      "p_bewndw": "Percentage of occupied dwellings",
      "p_koopw": "Percentage of owner-occupied homes",
      "p_huurw": "Percentage of rented homes",
      "p_wcorpw": "Percentage of homes owned by housing corporations",
      "p_bjj2k": "Percentage of homes built before 2000",
      "p_bjo2k": "Percentage of homes built from 2000 onwards",
      "g_ele": "Average electricity consumption (total)",
      "g_gas": "Average gas consumption (total)",
      "p_stadsv": "Percentage of homes with district heating",
      "ste_mvs": "Degree of urbanization",
      "ste_oad": "Address density",
      "pst_dekp": "Postal code coverage percentage",
      "a_opp_ha": "Total area (hectares)",
      "a_lan_ha": "Land area (hectares)",
      "a_wat_ha": "Water area (hectares)",
      "a_inkont": "Number of income recipients",
      "g_ink_po": "Average income per recipient",
      "g_ink_pi": "Average income per inhabitant",
      "p_ink_li": "40% of population with lowest income",
      "p_ink_hi": "20% of population with highest income",
      "p_hh_li": "40% of households with lowest income",
      "p_hh_hi": "20% of households with highest income",
      "p_hh_osm": "Household below or around the social minimum",
      "a_soz_wb": "Social assistance benefits recipients",
      "a_soz_ao": "Disability benefits recipients",
      "a_soz_ww": "Unemployment benefits recipients",
      "a_soz_ow": "Old-age benefits recipients",
      "a_bedv": "Total business establishments",
      "a_bed_a": "Business establishments: Agriculture, forestry, and fishing",
      "a_bed_bf": "Business establishments: Industry and energy",
      "a_bed_gi": "Business establishments: Trade and hospitality",
      "a_bed_hj": "Business establishments: Transport, information, and communication",
      "a_bed_kl": "Business establishments: Financial services and real estate",
      "a_bed_mn": "Business establishments: Business services",
      "a_bed_ru": "Business establishments: Culture, recreation, and other services",
      "a_pau": "Total passenger cars",
      "a_bst_b": "Passenger cars: Petrol",
      "g_pau_hh": "Passenger cars per household",
      "g_pau_km": "Passenger cars per km²",
      "a_m2w": "Motorcycles",
      "g_afs_hp": "Distance to general practitioner",
      "g_afs_gs": "Distance to large supermarket",
      "g_afs_kv": "Distance to daycare center",
      "g_afs_sc": "Distance to school",
      "g_3km_sc": "Number of schools within 3 km",
    }
    // Factors grouped for the dropdown
    const groupedFactors = {
   "Demographics": [
    { key: "a_inw", description: "Number of inhabitants" },
    { key: "a_man", description: "Number of male inhabitants" },
    { key: "a_vrouw", description: "Number of female inhabitants" },
    ], 
    "Households and Housing": [
    { key: "a_hh", description: "Total number of households" },
    { key: "g_hhgro", description: "Average household size" },
    { key: "bev_dich", description: "Population density (inhabitants per km²)" },
    { key: "a_woning", description: "Total housing stock" },
    { key: "p_1gezw", description: "Percentage of single-family homes" },
    { key: "p_mgezw", description: "Percentage of multi-family homes" },
    { key: "p_bewndw", description: "Percentage of occupied dwellings" },
    { key: "p_koopw", description: "Percentage of owner-occupied homes" },
    { key: "p_huurw", description: "Percentage of rented homes" },
    { key: "p_wcorpw", description: "Percentage of homes owned by housing corporations" },
    { key: "p_bjj2k", description: "Percentage of homes built before 2000" },
    { key: "p_bjo2k", description: "Percentage of homes built from 2000 onwards" }
    ],
    "Economy and Income": [
    { key: "a_inkont", description: "Number of income recipients" },
    { key: "g_ink_po", description: "Average income per recipient" },
    { key: "g_ink_pi", description: "Average income per inhabitant" },
    { key: "p_ink_li", description: "40% of population with lowest income" },
    { key: "p_ink_hi", description: "20% of population with highest income" },
    { key: "p_hh_li", description: "40% of households with lowest income" },
    { key: "p_hh_hi", description: "20% of households with highest income" },
    { key: "p_hh_osm", description: "Household below or around the social minimum" },
    { key: "a_soz_wb", description: "Social assistance benefits recipients" },
    { key: "a_soz_ao", description: "Disability benefits recipients" },
    { key: "a_soz_ww", description: "Unemployment benefits recipients" },
    { key: "a_soz_ow", description: "Old-age benefits recipients" }
    ], 
    "Infrastructure and Mobility": [
    { key: "a_pau", description: "Total passenger cars" },
    { key: "a_bst_b", description: "Passenger cars: Petrol" },
    { key: "g_pau_hh", description: "Passenger cars per household" },
    { key: "g_pau_km", description: "Passenger cars per km²" },
    { key: "a_m2w", description: "Motorcycles" },
    { key: "g_afs_hp", description: "Distance to general practitioner" },
    { key: "g_afs_gs", description: "Distance to large supermarket" },
    { key: "g_afs_kv", description: "Distance to daycare center" },
    { key: "g_afs_sc", description: "Distance to school" },
    { key: "g_3km_sc", description: "Number of schools within 3 km" }
    ],
};
    const linePaths = {};
    const descriptions = Object.values(column_descriptions);
    
    let currentZoomLevel = 1; //to track the current zoom level throughout all functions
    
    // Initial Map Load
    loadData();
    updateFactorList();

    // Initial load
    loadLineChart();
    

// Load data needed for the symbol map: geographical data and parts of the clusterdata. Then, start function for rendering the map     
function loadData() { 
      d3.select("#loading-icon").style("display", "block");  //show the loading icon
      d3.select("#granularity-display").style("display", "none"); //hide the granularity display
    // load GeoJSON data for all granularities
      const GeoPromises = [ // use this promise-constant to make sure the next function is not called when the data isn't loaded yet
        d3.json("data/merged_data_reprojected_GM_1.geojson").then(GeoDataGemeente => { // fetch the GeoJSON file for the granularity 'municipality' and place it in the GeoPromises array
          console.log(`Loaded GeoJSON Data (gemeente)`);
          return GeoDataGemeente; 
        }).catch(error => {
          console.error(`Error loading GeoJSON data (gemeente):`, error);
        }), 
        
        d3.json("data/merged_data_reprojected_WK_1.geojson").then(GeoDataWijk => { // fetch the GeoJSON file for the granularity 'wijk' and place it in the GeoPromises array
          console.log(`Loaded GeoJSON Data (wijk)`);
          return GeoDataWijk; 
        }).catch(error => {
          console.error(`Error loading GeoJSON data (wijk):`, error);
        }),     
        
        Promise.all([ // fetch GeoJSON file (wihch is divided over 2 files) for the granularity 'buurt' and place it in the GeoPromises array
            d3.json("data/merged_data_part1_1.geojson"),
            d3.json("data/merged_data_part2_1.geojson")
          ])
          .then(([geoDataPart1, geoDataPart2]) => { // Combine both parts horizontally
            const GeoDataBuurt = {
              type: "FeatureCollection", // collection of geographical features
              features: [...geoDataPart1.features, ...geoDataPart2.features] // extract features from the two geojson files and combine into a single array
            };
            console.log(`Loaded GeoJSON Data (buurt)`);
            return GeoDataBuurt; 
          }).catch(error => {
            console.error(`Error loading GeoJSON data (buurt):`, error);
          })      
      ];

    // load the cluster files and create a map where region ID is coupled to cluster number (perhaps the mapping is not necessary and the data file can be used directly)
      const granularities = ["buurt", "wijk", "gemeente"]; // granularities to iterate over
      const clusterFiles = {buurt: "data/clustered_BU_1.csv", // cluster file per granularity
                            wijk: "data/clustered_WK_1.csv",
                            gemeente: "data/clustered_GM_1.csv"};

      let clusterMapGemeente = {}; // variables to store the clustermaps in
      let clusterMapWijk = {};
      let clusterMapBuurt = {};

      const clusterPromises = granularities.map(granularity => { // use this promise-constant to make sure the next function is not called when the data isn't loaded yet
        const clusterFile = clusterFiles[granularity]; //get the cluster file
        return d3.csv(clusterFile).then(clusterData => {            
          const clusterMap = {}; //create a map where region ID is coupled to cluster number 
          //console.log(clusterData);
          clusterData.forEach(row => {
            if (row.ID && row.cluster) { 
              clusterMap[row.ID.trim()] = row.cluster.trim(); // Normalize both ID and cluster
            
            }
          });
          console.log(`Created Cluster Map (${granularity})`); 
          
          if (granularity === "buurt") { //store the clustermap in the correct variable
              clusterMapBuurt = clusterMap;
          } else if (granularity === "wijk") {
              clusterMapWijk = clusterMap;
          } else if (granularity === "gemeente") {
              clusterMapGemeente = clusterMap;
          }
        }).catch(error => {
          console.error(`error loading clustered CSV data for ${granularity}:`, error); 
        });
      });

      //make sure all data is loaded before starting the next function 
      Promise.all([...GeoPromises, ...clusterPromises]).then(results => {
        const [GeoDataGemeente, GeoDataWijk, GeoDataBuurt] = results.slice(0,3); //gives the loaded geo data the correct names

        // Call the next function with all the loaded data
        renderMap(GeoDataGemeente, GeoDataWijk, GeoDataBuurt, clusterMapGemeente, clusterMapWijk, clusterMapBuurt);
        d3.select("#loading-icon").style("display", "none"); //hide the loading icon
        d3.select("#granularity-display").style("display", "block"); //show the granularity display
    }).catch(error => {
        console.error("Error loading all data:", error);
        d3.select("#loading-icon").style("display", "none"); //hide the loading icon
    });
}

// render the geographical/symbol map
function renderMap(GeoDataGemeente, GeoDataWijk, GeoDataBuurt, clusterMapGemeente, clusterMapWijk, clusterMapBuurt) {
      console.log("started rendering the map"); 
      
      //settings
      const width = 600, height = 525; //map dimensions
      const zoomThreshold1 = 5; // level of zoom at which the map changes granularity from municipality to district
      const zoomThreshold2 = 15; // level of zoom at which the map changes granularity from district to neighborhood
      const radius = 3; // circle radius
      const fillColor = "#e0e0e0"; 
      const highlightColor = "#9c9b9b"; 
      const borderColor = "#333"; 

      //const clusterColors = d3.scaleOrdinal(d3.schemeCategory10); // circle colors (identical to those in the line chart) 

      const projection = d3.geoMercator() //set up map projection 
                           .center([5.5, 52])
                           .scale(5000)
                           .translate([width / 2, height / 2]);

      const path = d3.geoPath().projection(projection); //transform geojson data into a path that can be rendered 

      const geoMap = d3.select("#geo-map"); //selects the html-container for the map
  
      const svg = geoMap.append("svg") //create SVG element
                        .attr("width", width)
                        .attr("height", height)

      //zoom behaviour 
      const g = svg.append("g"); //create a group for zooming
  
      let prevcurrentZoomLevel = 1; //to track the previous zoom level
      
      function throttle(func, limit) { //to limit how often the zoom handler runs: reduce CPU load and improve responsiveness
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
      
      const zoom = d3.zoom()
                     .scaleExtent([1, 30]) // Limit zoom scale 
                     .translateExtent([[0, 0], [width, height]]) // Limit pan (ensure pan does not go out of bounds)
                     .on("zoom", throttle((event) => { // work via throttle to reduce CPU load
                       currentZoomLevel = event.transform.k; //update the current zoom level
                       
                       g.attr("transform", event.transform); //zoom
                       g.selectAll("path").attr("stroke-width", 1 / currentZoomLevel); // keep line width constant
                       g.selectAll("circle").attr("r", radius / currentZoomLevel); // keep circle radius constant

                       if ((prevcurrentZoomLevel < zoomThreshold1 && currentZoomLevel >= zoomThreshold1) || (prevcurrentZoomLevel >= zoomThreshold1 && currentZoomLevel < zoomThreshold1)) { //when the currentZoomLevel increases or decreases past the first zoom threshold the shown layer is updated
                        if(currentZoomLevel < zoomThreshold1){
                          showLayer("municipality");
                          newGranularity = "gemeente";
                          d3.select("#granularity-display").text(`Granularity: municipality`); // Update the text in the granularity display
                        } else {
                          showLayer("district");
                          newGranularity = "wijk"; 
                          d3.select("#granularity-display").text(`Granularity: district`); // Update the text in the granularity display
                        }
                        } else if ((prevcurrentZoomLevel < zoomThreshold2 && currentZoomLevel >= zoomThreshold2) || (prevcurrentZoomLevel >= zoomThreshold2 && currentZoomLevel < zoomThreshold2)) { //when the currentZoomLevel increases or decreases past the second zoom threshold the shown layer is updated
                          if(currentZoomLevel < zoomThreshold2){
                            showLayer("district");
                            newGranularity = "wijk"; 
                            d3.select("#granularity-display").text(`Granularity: district`); // Update the text in the granularity display
                          } else {
                            showLayer("neighborhood");
                            newGranularity = "buurt"; 
                            d3.select("#granularity-display").text(`Granularity: neighborhood`); // Update the text in the granularity display
                          }
                        }

                       //update the state variable, and calls the update of the line chart
                       if (state.granularity !== newGranularity) {
                            state.granularity = newGranularity;
                            new_factors = true;
                            if (newGranularity == "gemeente") {
                              state.city = [];
                              state.favorite = null;
                              state.city_codes = [];
                              state.cluster_buttons_clicked = [];
                              state.clusters_watching = [];

                            }
                            else if (newGranularity == "wijk") {
                              state.city = [];
                              state.favorite = null;
                              state.city_codes = [];
                              state.cluster_buttons_clicked = [];
                              state.clusters_watching = [];
                            }
                            else {
                              state.city = [];
                              state.favorite = null;
                              state.city_codes = [];
                              state.cluster_buttons_clicked = [];
                              state.clusters_watching = [];
                            }
                            updateLineChart(); // Synchronize the line chart with the map
                            update_buttons_colors();
                            updateFactorList();
                            renderCityList();
                            loadScatterData();
                        }
                       prevcurrentZoomLevel = currentZoomLevel;
                     }, 50)); //throttle limit
  
      svg.call(zoom); //apply zoom behaviour to the svg

      // create a tooltip element that can be reused later 
      if (d3.select("#tooltip").empty()) {
        d3.select("body").append("div")
          .attr("id", "tooltip")
          .style("position", "absolute")
          .style("display", "none")
          .style("background", "white")
          .style("border", "1px solid #ccc")
          .style("padding", "10px")
          .style("border-radius", "5px")
          .style("pointer-events", "none")
          .style("z-index", "9999");
      }
  
      function showLayer(layerName) { //show a layer
        g.selectAll(".layer").style("display", "none"); //make sure none are visible
        g.select(`.layer.${layerName}`).style("display", "block"); //show the correct layer
        const selectedLayer = g.select(`.layer.${layerName}`);
        selectedLayer.style("display", "block");
        currentLayer = layers.find(layer => layer.name === layerName);

        d3.select('#granularity-display').style("display", "block"); //show granularity display 

        console.log(`Switched to layer: ${layerName}`);
      }
  
      //create groups within the g-group which will function as layers for the different granularities
      const layer_GM = g.append("g").attr("class", "layer municipality"); //create a group for the municipality layer, and assign the class names layer and municipality
      const layer_WK = g.append("g").attr("class", "layer district"); //create a group for the district layer, and assign the class names layer and district
      const layer_BU = g.append("g").attr("class", "layer neighborhood"); //create a group for the district layer, and assign the class names layer and district       
  
      //define the information belonging to each layer
      const layers = [{ name: "municipality", data: GeoDataGemeente, clusterMap: clusterMapGemeente, idKey: "gm_code", idName: "gm_naam", municipality: "gm_naam", layerGroup: layer_GM },
                      { name: "district", data: GeoDataWijk, clusterMap: clusterMapWijk, idKey: "wk_code", idName: "wk_naam", municipality: "gm_naam", layerGroup: layer_WK },
                      { name: "neighborhood", data: GeoDataBuurt, clusterMap: clusterMapBuurt, idKey: "geo_ID", idName: "bu_naam", municipality: "gm_naam", layerGroup: layer_BU }];
      console.log("Defined layer information: ", layers);  
  
      //iterate to render the paths/circles belonging to each layer
      layers.forEach(layer => { 
        console.log(`iteration: layer ${layer.name}`); 
        if (!layer.data || !layer.data.features) {
            console.warn(`Layer ${layer.name} has no valid data.`);
            return;
        }

        const layerGroup = layer.layerGroup; // retrieve the correct layer-group
        
        //add paths
        layerGroup.selectAll("path") 
                  .data(layer.data.features)
                  .join("path")
                  .attr("d", path)
                  .attr("fill", fillColor) //fill color of the map
                  .attr("stroke", borderColor) //stroke color of the map
                  .on("mouseover", (event, d) => {
                    const tooltipTitle = d.properties[layer.idName]; //name of the selected region
                    const tooltipMunicipality = d.properties[layer.municipality]; //name of the municipality of the selected region 
                    const regionId = d.properties[layer.idKey];
                    const tooltipCluster = layer.clusterMap[regionId]?.trim(); //cluster number of the selected region
                    const tooltipContent = `
                      <div style="text-align: center;">
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">${tooltipTitle}</div>
                        <div>
                          <strong>Municipality: </strong>${tooltipMunicipality}<br>
                          <strong>Cluster: </strong>${tooltipCluster || "Unknown"}
                        </div>
                      </div>
                    `;
                    d3.select("#tooltip")
                        .html(tooltipContent)
                        .style("left", `${event.pageX + 10}px`)
                        .style("top", `${event.pageY + 10}px`)
                        .style("display", "block")
                        .style("position", "fixed")
                        .style("background", "white")
                        .style("border", "1px solid black")
                        .style("padding", "10px")
                        .style("z-index", "9999");
                  })
                  .on("mousemove", (event) => {
                    d3.select("#tooltip")
                      .style("left", `${event.pageX + 10}px`)
                      .style("top", `${event.pageY + 10}px`);
                  })
                  .on("mouseout", () => {
                    d3.select("#tooltip").style("display", "none");
                    // Reset cluster highlighting
                    Object.values(linePaths).forEach(path => {
                      path.attr("stroke-width", 2).attr("opacity", 1);
                    });
                  })
                  .on("click", (event, d) => {
                    layerGroup.selectAll("path").attr("fill", fillColor); //get all regions back to basic color
                    d3.select(event.currentTarget).attr("fill", highlightColor); //highlight the clicked region
                    //get region and cluster information, and feed to line chart
                    const regionId = d.properties[layer.idKey];
                    const cluster = layer.clusterMap[regionId]?.trim();
                    if (cluster !== undefined && cluster !== null) {
                      highlightCluster(cluster);
                    }
                    if (state.city.length >= 5) {
                      alert("You can only select up to 5 regions.");
                    }
                    else if (regionId !== undefined && regionId !== null) {
                      if (state.city_codes.includes(regionId)) {
                        alert("This city has already been selected.");
                      }
                      else {
                        state.city.push({id: regionId, name: d.properties[layer.idName], cluster: cluster});
                        state.city_codes.push(regionId);
                        if (state.cluster_buttons_clicked.includes(cluster)) {
                          state.cluster_buttons_clicked = state.cluster_buttons_clicked.filter(item => item !== cluster);
                          state.clusters_watching = state.clusters_watching.filter(item => item !== cluster);
                        } 
                        handleClusterButtonClick(cluster);
                        renderCityList();
                      }
                    }
                  })
        
        //calculate centroids that lie within the polygons for adding circles 
        layer.data.features.forEach(d => {
          let centroid = path.centroid(d); // Calculate the centroid of the path (in screen coordinates)
          const geoCentroid = projection.invert(centroid); // Convert the centroid back to geographic coordinates
          
          const isInsidePolygon = d3.geoContains(d, geoCentroid); //check if the coordinate falls within the path/ polygon
          if (!isInsidePolygon) { //if the coordinate falls outside of its polygon, try to buffer the region and use Turf to find a point inside the polygon
            //console.log('Centroid is outside the polygon, using Turf to find an interior point')
            const geoJsonPolygon = { // Create a GeoJSON feature for Turf operations
              type: 'Feature',
              geometry: d.geometry,
              properties: {}
            };
            try {
              const bufferedPolygon = turf.buffer(geoJsonPolygon, -100, { units: 'meters' });// Attempt to buffer the polygon by the calculated distance
              if (bufferedPolygon && bufferedPolygon.geometry.coordinates.length > 0) {//if buffering was successfull: find an interior point within the buffered polygon
                const interiorPoint = turf.pointOnFeature(bufferedPolygon);
                centroid = projection(interiorPoint.geometry.coordinates); // Convert to screen coordinates
              } else { // Fall back to the original polygon if buffering fails
                //console.log('Buffering failed or resulted in an invalid polygon. Using the original polygon.');
                const interiorPoint = turf.pointOnFeature(geoJsonPolygon);
                centroid = projection(interiorPoint.geometry.coordinates); // Convert to screen coordinates
              }
            } catch (error) { 
              console.error('Error during buffering or centroid calculation:', error);
              const interiorPoint = turf.pointOnFeature(geoJsonPolygon);
              centroid = projection(interiorPoint.geometry.coordinates); // Convert to screen coordinates
            }
          }
          d.centroid = centroid;// store the centroids for later use
        });

        //add circles 
        layerGroup.selectAll("circle") 
                  .data(layer.data.features)
                  .join("circle")
                  .attr("cx", d => d.centroid[0]) //extract the x-coordinate of the center of the geojson polygon data
                  .attr("cy", d => d.centroid[1]) //extract the y-coordinate of the center of the geojson polygon data
                  .attr("r", radius)
                  .attr("fill", d => {
                    const regionId = d.properties[layer.idKey]; // Match region ID from GeoJSON
                    const cluster = layer.clusterMap[regionId];   // Get cluster number from CSV
                    return cluster !== undefined ? color(cluster) : "#ccc"; // Assign color based on cluster
                  })
                  .on("mouseover", (event, d) => {
                    const tooltipTitle = d.properties[layer.idName]; //name of the selected region
                    const tooltipMunicipality = d.properties[layer.municipality]; //name of the municipality of the selected region 
                    const regionId = d.properties[layer.idKey];
                    const tooltipCluster = layer.clusterMap[regionId]?.trim(); //cluster number of the selected region
                    const tooltipContent = `
                      <div style="text-align: center;">
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">${tooltipTitle}</div>
                        <div>
                          <strong>Municipality: </strong>${tooltipMunicipality}<br>
                          <strong>Cluster: </strong>${tooltipCluster || "Unknown"}
                        </div>
                      </div>
                    `;
                    d3.select("#tooltip")
                        .html(tooltipContent)
                        .style("left", `${event.pageX + 10}px`)
                        .style("top", `${event.pageY + 10}px`)
                        .style("display", "block")
                        .style("position", "fixed")
                        .style("background", "white")
                        .style("border", "1px solid black")
                        .style("padding", "10px")
                        .style("z-index", "9999");
                  })
                  .on("mousemove", (event) => {
                    d3.select("#tooltip")
                      .style("left", `${event.pageX + 10}px`)
                      .style("top", `${event.pageY + 10}px`);
                  })
                  .on("mouseout", () => {
                    d3.select("#tooltip").style("display", "none");
                    // Reset cluster highlighting
                    Object.values(linePaths).forEach(path => {
                      path.attr("stroke-width", 2).attr("opacity", 1);
                    });
                  })
                  .on("click", (event, d) => {
                    const regionId = d.properties[layer.idKey];
                    const cluster = layer.clusterMap[regionId]?.trim();
                    layerGroup.selectAll("path").attr("fill", fillColor); //get all regions back to basic color
                    layerGroup.selectAll("path").filter(region => region.properties[layer.idKey] === regionId).attr("fill", highlightColor);// give the correct region the highlight color 
                    if (cluster !== undefined && cluster !== null) {
                      highlightCluster(cluster);
                    }
                    if (state.city.length >= 5) {
                      alert("You can only select up to 5 regions.");
                    }
                    else if (regionId !== undefined && regionId !== null) {
                      if (state.city_codes.includes(regionId)) {
                        alert("This city has already been selected.");
                      }
                      else {
                        state.city.push({id: regionId, name: d.properties[layer.idName], cluster: cluster});
                        state.city_codes.push(regionId);
                        if (state.cluster_buttons_clicked.includes(cluster)) {
                          state.cluster_buttons_clicked = state.cluster_buttons_clicked.filter(item => item !== cluster);
                          state.clusters_watching = state.clusters_watching.filter(item => item !== cluster);
                        } 
                        handleClusterButtonClick(cluster);
                        renderCityList();
                      }
                    }
                  });          
      });
  
      console.log("Rendering iterations finished"); 
      
      showLayer("municipality");
  
      geoMap.style("overflow", "hidden"); //ensure the map does not zoom outside of its container
}

//create the line chart
function loadLineChart() {
      //settings
      const clusterLineWidth = 3; 
      const clusterHoverWidth = 5; 
      const clusterHighlightWidth = 7; 
      
      const individualLineWitdh = 1.5; 
      const individualLineOpacity = 0.2; 

      const circleHighlightWidth = 7; 

      // start 
      let clusterFile;

      if (state.granularity === "buurt") {
        clusterFile = "data/clustered_BU_1.csv";
      } else if (state.granularity === "wijk") {
        clusterFile = "data/clustered_WK_1.csv";
      } else {
        clusterFile = "data/clustered_GM_1.csv";
      }
    
      d3.csv(clusterFile).then(data => {
        console.log("line chart cluster data loaded"); 
        
        const xLabels = ['2002', '2008', '2012', '2014', '2016', '2018', '2020', '2022']; // Extract years and scores
        const xYears = xLabels.map(year => +year); // Convert years to numeric values
        const clusters = d3.group(data, d => d.cluster); // Organize data by cluster
    
        // Create Line Chart
        const lineGraph = d3.select("#line-graph");
        lineGraph.selectAll("*").remove(); // Remove all previous elements
        const lineSvg = lineGraph.append("svg")
                                 .attr("width", 600)
                                 .attr("height", 500);
    
        const margin = { top: 20, right: 20, bottom: 50, left: 50 };
        const width = 600 - margin.left - margin.right;
        const height = 480 - margin.top - margin.bottom;
    
        const g = lineSvg.append("g")
                         .attr("transform", `translate(${margin.left},${margin.top})`);
    
        // Define a linear scale for the x-axis based on the year values
        const xScale = d3.scaleLinear()
          .domain([d3.min(xYears), d3.max(xYears)]) // Use the range of years
          .range([0, width]);
          
        // Define the x-axis using the linear scale
        const xAxis = d3.axisBottom(xScale)
            .tickValues(xYears) // Only place ticks for the specified years
            .tickFormat(d3.format("d")); // Format ticks as integers
    
        const yScale = d3.scaleLinear()
                         .domain([
                           d3.min(data.flatMap(d => {
                             return xLabels.map(label => parseFloat(d[label]) || 0);
                           }))-0.2, 
                           d3.max(data.flatMap(d => {
                             return xLabels.map(label => parseFloat(d[label]) || 0);
                           }))+0.2
                         ])
                         .range([height, 0]);
        //console.log("yScale domain:", yScale.domain());
        const yAxis = d3.axisLeft(yScale);  

        //add a clickable background
        g.append("rect")
          .attr("width", width)
          .attr("height", height)
          .attr("fill", "transparent") 
          .attr("pointer-events", "all") // Ensure it captures click events
          .on("click", () => {
            console.log('background click triggered');
            
            g.selectAll(".individual-line").remove(); // Remove all individual cluster lines
            
            Object.values(linePaths).forEach(path => { // Reset cluster highlighting
              console.log('trying to reset cluster highlighting')
              path.attr("stroke-width", clusterLineWidth).attr("opacity", 1);
            });
            
            d3.selectAll("#geo-map circle") //reset circles in geographical map
              .attr("stroke", null)
              .attr("stroke-width", null)
              .attr("opacity", 1);
          });
            
        // Axes
        g.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(xAxis);
        g.append("g")
          .call(d3.axisLeft(yScale));
        g.append("g").call(yAxis);
    
        clusters.forEach((clusterData, clusterId) => {
          const cumulativeTrends = xLabels.map(label => ({
            x: label,
            y: parseFloat(clusterData[0][label]) || 0 // Directly use the value for each label
          }));
          //console.log(`Cluster ${clusterId} cumulative trends:`, cumulativeTrends); // Debugging
          const normalizedClusterId = clusterId?.trim();
          // Draw the line using cumulative trends
          const path = g.append("path")
                        .datum(cumulativeTrends)
                        .attr("fill", "none")
                        .attr("stroke", color(normalizedClusterId))
                        .attr("stroke-width", clusterLineWidth)
                        .attr("d", d3.line()
                        .x(d => xScale(d.x))
                        .y(d => yScale(d.y)))
                        .on("click", () => {
                          console.log('cluster line click triggered'); 
                          highlightMapPoints(normalizedClusterId, currentLayer, circleHighlightWidth); // highlight corresponding regions on geographical map
                          highlightCluster(normalizedClusterId, clusterLineWidth, clusterHighlightWidth); // highlight the cluster line while making the others transparant 
                          //plotIndividualLines(clusterId, clusterFile, xLabels, g, xScale);
                          clusters.forEach((clusterData, clusterId) => {
                            if (clusterId === normalizedClusterId) { // Check if the current cluster matches the clicked one
                              console.log("cluster number of the clicked line: ", clusterId);
                              clusterData.forEach(item => {
                                console.log('trying to draw individual lines'); 
                                const cumulativeTrends = xLabels.map(label => ({
                                  x: label,
                                  y: parseFloat(item[`lbm_${label}`]) || 0 // Directly use the value for each label
                                }));
                                const regionId = item.ID; 
                                const itemPath = g.append("path")
                                                  .datum(cumulativeTrends)
                                                  .attr("fill", "none")
                                                  .attr("stroke", color(normalizedClusterId)) // Use consistent color for all items in the cluster
                                                  .attr("stroke-width", individualLineWitdh) // Thinner line for individual items
                                                  .attr("opacity", individualLineOpacity)
                                                  .attr("class", `individual-line`) //add the line to a cluster, so it can be removed when clicking on the background
                                                  .attr("region-id", regionId) // Store the region ID as a custom attribute
                                                  .attr("d", d3.line()
                                                    .x(d => xScale(d.x))
                                                    .y(d => yScale(d.y)))
                                                  .on("click", (event, d) => {
                                                    console.log('individual line click triggered'); 
                                                    
                                                    g.selectAll(".individual-line").attr("opacity", individualLineOpacity); //highlight the selected line
                                                    d3.select(event.currentTarget).attr("opacity", 1);
                                                    
                                                    const clickedRegionId = d3.select(event.currentTarget).attr("region-id"); //highlight the region of the line on the map
                                                    //console.log(clickedRegionId); 
                                                    highlightRegionOnMap(clickedRegionId, clusterId, currentLayer, circleHighlightWidth); 
                                                  });
                              });
                          }});
                        })
                        .on("mouseover", () => {
                          d3.select(path.node()).attr("stroke-width", clusterHoverWidth); // Highlight on hover
                        })
                        .on("mouseout", () => {
                          d3.select(path.node()).attr("stroke-width", clusterLineWidth);
                        }); 
          
          // Store the path for interactivity
          linePaths[normalizedClusterId] = path;
        });
        
        // Add labels
        g.append("text") //title
          .attr("x", width / 2)
          .attr("y", -5)
          .attr("text-anchor", "middle")
          .attr("font-size", "16px")
          .text("Normalized LBM Scores Over Time by Cluster");
        g.append("text") //y-axis
          .attr("x", -height / 2)
          .attr("y", -35)
          .attr("transform", "rotate(-90)")
          .attr("text-anchor", "middle")
          .attr("font-size", "12px")
          .text("Normalized LBM Score");
        g.append("text") //x-axis
          .attr("x", width / 2)
          .attr("y", height + 40)
          .attr("text-anchor", "middle")
          .attr("font-size", "12px")
          .text("Year");
  
        //add legend 
        const legendContainer = d3.select("#legend")
          .html("") // Clear any existing legend
          .style("display", "flex")
          .style("justify-content", "center")
          .style("flex-wrap", "wrap")
          .style("gap", "20px")
          .style("margin-top", "20px");
    
         // Create a fixed color mapping
         const clusterIds = Array.from(clusters.keys()).sort((a, b) => a - b); // Sort cluster IDs to ensure order
         const fixedColorMapping = {};
         clusterIds.forEach((clusterId, index) => {
           fixedColorMapping[clusterId] = d3.schemeCategory10[index % 10]; // Assign a color from the color scheme
         });
    
        // Function to get the color for a cluster
        const getColor = clusterId => fixedColorMapping[clusterId];
    
          
        clusterIds.forEach((_, clusterId) => {
          const legendItem = legendContainer.append("div")
                                            .attr("class", "legend-item")
                                            .style("display", "flex")
                                            .style("align-items", "center")
                                            .style("margin", "5px");
          legendItem.append("div")
                    .style("width", "20px")
                    .style("height", "20px")
                    .style("background-color", getColor(clusterId))
                    .style("margin-right", "10px");
    
          legendItem.append("span")
            .text(`Cluster ${clusterId}`)
            .style("font-size", "12px");
          // Add hover interaction for legend
        });
      }).catch(error => {
        console.error("Error loading cluster data:", error);
      });
}

    
function updateLineChart() {
      const granularity = state.granularity;
      loadLineChart();
}


function highlightCluster(clusterId, standardLineWidth, HighlightLineWidth) {
      console.log(`Attempting to highlight cluster: ${clusterId}`);
      // Reset all lines to their default style and make them transparant 
      Object.values(linePaths).forEach(path => {
        path.attr("stroke-width", standardLineWidth).attr("opacity", 0.5); // Reset other lines
      });

      // Highlight the selected cluster
      const selectedPath = linePaths[clusterId];
      if (selectedPath) {
        selectedPath.attr("stroke-width", HighlightLineWidth).attr("opacity", 1); // Highlight
        console.log(`Highlighted cluster: ${clusterId}`);
      } else {
        console.warn(`No path found for cluster: ${clusterId}`);
      }
}

    
function highlightMapPoints(clusterId, layer, highlightWidth) {
      console.log(`Highlighting map points for cluster: ${clusterId}`);

      d3.selectAll("#geo-map circle") // Reset styles for all points and make then a bit transparant
        .attr("r", 3 / currentZoomLevel)
        //.attr("stroke", null)
        //.attr("stroke-width", null)
        .attr("opacity", 0.5);
      
      // Highlight points belonging to the clicked cluster
      d3.selectAll("#geo-map circle")
        .filter(function (d) {
          const regionId = d.properties[layer.idKey]; // Retrieve region ID based on the layer's idKey
          const cluster = layer.clusterMap[regionId]?.trim(); // Get cluster from clusterMap
          //console.log(`Region ID: ${regionId}, Cluster: ${cluster}`);
          //console.log(`Region Data:`, d.properties);

          return cluster === clusterId; // Match the cluster ID
        })
        .attr("r", 6 / currentZoomLevel)
        //.attr("stroke", color(clusterId)) // Add a highlight stroke
        //.attr("stroke-width", highlightWidth)
        .attr("opacity", 1); // Ensure visibility
}

function highlightRegionOnMap(regionId, clusterId, layer, highlightWidth) {
      console.log('highlighting individual region on map for region ID: ${regionId}');
  
      currentZoomLevel = event.transform.k; //needed to keep the circle radius constant throughout zooming
  
      d3.selectAll("#geo-map circle") //reset the map highlighting and make then a bit transparant
        .attr("r", 3/ currentZoomLevel)
        //.attr("stroke", null)
        //.attr("stroke-width", null)
        .attr("opacity", 0.5);
    
      d3.selectAll("#geo-map circle") // Highlight the corresponding region
        .filter(d => d.properties && d.properties[layer.idKey] === regionId)
        //.attr("stroke", color(clusterId))
        //.attr("stroke-width", highlightWidth)
        .attr("r", 6 / currentZoomLevel)
        .attr("opacity", 1);
    
      console.log(`Region ${regionId} highlighted on the map.`);
}

    /*const regionId = d.properties[layer.idKey];
                    const cluster = layer.clusterMap[regionId]?.trim();
                    console.log(`Region ID: ${regionId}, Cluster: ${cluster}`); 
                    console.log(`Cluster retrieved:`, cluster);*/
    // Add an event listener to the map background for resetting styles
   /* d3.select("#geo-map")
        .on("click", function(event) {
          console.log("Map background clicked. Resetting styles.");

          // Reset styles for all points
          d3.selectAll("#geo-map circle")
            .attr("stroke", null)
            .attr("stroke-width", null)
            .attr("opacity", 1);

          // Optionally reset the tooltip or other elements
          //d3.select("#tooltip").style("display", "none");
        });
*/
      // Ensure the click events on circles do not propagate to the background
      d3.selectAll("#geo-map circle")
        .on("click", function(event) {
          event.stopPropagation(); // Prevent event from propagating to the map background
     
        });



    // ----------------------------------------------------
    // ----------------------------------------------------
    // ----------------------------------------------------
    // SECOND VISUALIZATION
    // ----------------------------------------------------
    // ----------------------------------------------------
    // ----------------------------------------------------


    function renderCityList() {
      const cityListContainer = document.getElementById("city-list");

      cityListContainer.innerHTML = ""; // Clear existing content

      state.city.forEach((city, index) => {
          const cityCard = document.createElement("div");
          cityCard.className = "city-card";

          cityCard.innerHTML = `
              <p><strong>Name:</strong> ${city.name}</p>       
              <p><strong>Cluster:</strong> ${city.cluster}</p>   
              <button onclick="removeCity(${index})">Remove</button>
               <button onclick="toggleFavorite(${index})" class="${city.id === state.favorite ? 'favorite-active' : 'normal-city'}">
                ${city.id === state.favorite ? '★' : '☆'}
              </button>      
              `;

          cityListContainer.appendChild(cityCard);
      });
    }

    function removeCity(index) {
      if (state.favorite == state.city[index].id) {
        state.favorite = null;
      }
      state.city.splice(index, 1);
      state.city_codes.splice(index, 1);
      renderCityList();
      loadScatterData();
    }

    // Function to toggle favorite status
    function toggleFavorite(index) {
      if (state.favorite == state.city[index].id) {
        state.favorite = null;
      } else if (state.favorite == null) {
        state.favorite = state.city[index].id;
      }
      else {
        alert("Only one favorite city is allowed.");
        return;
      }
      renderCityList();
      loadScatterData();
    }

    function update_buttons_colors() {

      for (let i = 0; i <= 4; i++) {
        if (state.cluster_buttons_clicked.includes(i.toString())) {
          d3.select(`#cluster-button-${i}`).style("background-color", color(i.toString()));
        }
        else {
          d3.select(`#cluster-button-${i}`).style("background-color", "#5fada9");
        }
      }
    }


    function handleClusterButtonClick(cluster) {
      // Remove cluster from density plots
      if (state.cluster_buttons_clicked.includes(cluster)) {
        state.cluster_buttons_clicked = state.cluster_buttons_clicked.filter(item => item !== cluster);
        state.clusters_watching = state.clusters_watching.filter(item => item !== cluster);
      } 
      else {
        state.cluster_buttons_clicked.push(cluster);
        state.clusters_watching.push(cluster);
      }
      update_buttons_colors();
      loadScatterData();
    }

    function getCorrelations() {
      return new Promise((resolve, reject) => {
        let final_factors = [];

        if (state.granularity === "buurt") {
          file = `data/2_visualization/Buurt/BU_correlations.csv`;
        } else if (state.granularity === "wijk") {
          file = `data/2_visualization/Wijk/WK_correlations.csv`;
        } else {
          file = `data/2_visualization/Gemeente/GM_correlations.csv`;
        }

        d3.dsv(";", file)
          .then(data => {

            const factorsWithCorrelations = [];

            data.forEach(row => {
              const combinedValue = row["factor,lbm"];

              // Split the string to extract the factor and correlation
              if (combinedValue && combinedValue.includes(',')) {
                const [factor, rawCorrelation] = combinedValue.split(',');

                // Parse the correlation value
                const correlation = parseFloat(rawCorrelation);
                allCorrelations.push({factor,correlation});
                correlationMap = allCorrelations.reduce((map, item) => {
                    map[item.factor] = item.correlation;
                  return map;
                }, {});

                // Check correlation threshold
                if (Math.abs(correlation) > 0.35) {
                  factorsWithCorrelations.push({ factor, correlation });
                }
              }
            });

            // Sort the array by correlation (ascending)
            factorsWithCorrelations.sort((a, b) => a.correlation - b.correlation);

            // Get the 3 lowest and 3 highest correlations
            const lowestFactors = factorsWithCorrelations.slice(0, 3);
            const highestFactors = factorsWithCorrelations.slice(-3);

            lowestFactors.forEach(p => {final_factors.push(p.factor)});
            highestFactors.forEach(p => {final_factors.push(p.factor)});

            resolve(final_factors); // Resolve the Promise with final_factors
          })
          .catch(error => {
            console.error(`Error loading file ${file}:`, error);
            reject(error); // Reject the Promise on error
          });
      });
    }

    function loadScatterData() {

      let file, names_codes;
      const promises = [];
      data_final = {};

      factor_watch_list.forEach(factor => {
        data_final[factor] = {};  // Initialize the factor key in data_final

        if (state.granularity === "buurt") {
          file = `data/2_visualization/Buurt/BU_means_with_clusters.csv`;
          names_codes = "BU_name";
        } else if (state.granularity === "wijk") {
          file = `data/2_visualization/Wijk/WK_means_with_clusters.csv`;
          names_codes = "WK_name";
        } else {
          file = `data/2_visualization/Gemeente/GM_means_with_clusters.csv`;
          names_codes = "GM_name";
        }

        const promise = d3.dsv(";", file).then(data => {

          collumns_file = data["columns"];

          // Initialize the year key in the factor object if it doesn't exist
          data_final[factor] = data.map(row => {

            const factorValue = parseFloat(row[factor].replace(',', '.'));
            const lbmValue = parseFloat(row["lbm"].replace(',', '.'));
            const cluster = parseInt(row["cluster"]).toString();
          
            if (state.city_codes.includes(row["ID"]) || (state.clusters_watching.includes(cluster) && !isNaN(factorValue) && !isNaN(lbmValue))) {
                return {
                    code: row["ID"],
                    name: row[names_codes],
                    cluster: cluster,
                    lbm: lbmValue,
                    factor: factorValue
                };
            }

            // If the factor or lbm is invalid, return null or skip this entry
            return null;
          }).filter(item => item !== null); // Remove null entries if any
        }).catch(error => {
              console.error(`Error loading file ${file}:`, error);
        });

        promises.push(promise);
      });

      Promise.all(promises).then(() => {
          createScatterPlot(data_final);
      });
    } 

    function createScatterPlot(data_org) {
      const width = 300;
      const height = 300;
      const margin = { top: 20, right: 30, bottom: 50, left: 50 };

      d3.select("#scatter-plot-container").html(""); // Clear the container

      let has_data = false;

      Object.keys(data_org).forEach((factorKey) => {
        const data = data_org[factorKey];
        if (data.length > 0) {
          has_data = true;
        }
      });

      if (!has_data) {
        d3.select("#scatter-plot-container").append("p").text("No data available for the selected clusters.");
        return;
      }

      // Select the container for all plots
      const plotsContainer = d3.select("#scatter-plot-container");

      // Add a tooltip
      const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("display", "none")
        .style("position", "absolute")
        .style("background", "white")
        .style("border", "1px solid black")
        .style("padding", "3px")
        .style("font-size", "12px")
        .style("pointer-events", "none")
        .style("z-index", "9999");  // Ensuring tooltip is above other elements


      function mapPointsToContours(data, contours, xScale, yScale) {
        const pointToContourMap = [];

        contours.forEach((contour, contourIndex) => {
          const polygons = contour.coordinates;
          data.forEach((point) => {
            const x = xScale(point.factor);
            const y = yScale(point.lbm);
            polygons.forEach((polygon) => {
              if (d3.polygonContains(polygon[0], [x, y])) {
                pointToContourMap.push({ point, contourIndex, density: contour.value });
              }
            });
          });
        });

        return pointToContourMap;
      }
      
      // For each factor in the data, create a scatter plot
      Object.keys(data_org).forEach((factorKey) => {
        const data = data_org[factorKey];
        const highlightData = data.filter(d => state.city_codes.includes(d.code));

        const container = plotsContainer
          .append("div")
          .attr("class", "scatter-plot-container")
          .style("width", `${width + margin.left + margin.right}px`)
          .style("height", `${height + margin.top + margin.bottom + 60}px`)
          .style("background-color", "#fff");
          

         
        container.append("h4").text(`${column_descriptions[factorKey]}`);
        currentCorrelation = correlationMap[factorKey];
        
        // Highlight the factors with the biggest potential i.e. the ones that differ 20 % of the mean
        if (highlightData) {
          
          const averageValue = d3.mean(data, d => d.factor);
    
          if ( currentCorrelation < -0.35 && highlightData.factor > averageValue * 1.2) {
       
            container.style("box-shadow", "0 0 15px 5px rgba(255, 0, 0, 0.5)");
          } else if (currentCorrelation > 0.35 && highlightData.factor < averageValue * 0.8) {
            
            container.style("box-shadow", "0 0 15px 5px rgba(0, 0, 255, 0.5)");

          }
        }

        const svg = container
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);


        const min_factor = d3.min(data, (d) => d.factor);
        const max_factor = d3.max(data, (d) => d.factor);
        const min_lbm = d3.min(data, (d) => d.lbm);
        const max_lbm = d3.max(data, (d) => d.lbm);

        const numberOfDigits = Math.floor(Math.log10(max_factor)) + 1;

        let value_adjustment = 0.8;

        for (let i = 0; i < numberOfDigits - 1; i++) {
          value_adjustment *= 10;
        }


        // Adjust the minimum x value based on the number of digits in the max factor value 

        let new_min_x = 0;

        if (numberOfDigits < 4) {
          new_min_x = Math.max(0, min_factor) - value_adjustment;
          if (new_min_x < 0) {
            new_min_x = 0;
          }
        }
        else {
          new_min_x = Math.max(0, min_factor) - value_adjustment;
        }

        // Use the domain to scale the x and y axis based on the minimum values in the lbm and factor data
        const xScale = d3.scaleLinear()
          .domain([new_min_x, max_factor + value_adjustment / 2]) 
          .range([0, width]);

        const yScale = d3.scaleLinear()
          .domain([Math.max(0, min_lbm) - 0.1, max_lbm + 0.3])     
          .range([height, 0]);

        const density = d3.contourDensity()
          .x((d) => xScale(d.factor))
          .y((d) => yScale(d.lbm))
          .size([width, height])
          .bandwidth(20)(data);

        const densityValues = density.map(d => d.value);
        const minDensity = d3.min(densityValues);
        const maxDensity = d3.max(densityValues);

        const colorScale = d3.scaleSequential(d3.interpolateViridis)
          .domain([minDensity, maxDensity]);

        const pointToContourMap = mapPointsToContours(data, density, xScale, yScale);

        svg.selectAll("path")
          .data(density)
          .enter()
          .append("path")
          .attr("d", d3.geoPath())
          .attr("fill", (d) => colorScale(d.value))
          .attr("stroke", "none")
          .on("mouseover", (event, d) => {
            const pointsInRegion = pointToContourMap.filter(entry => entry.density === d.value);

            svg.selectAll("circle")
              .attr("stroke", "none")
              .attr("opacity", 0.3);

            pointsInRegion.forEach(({ point }) => {
              svg.append("circle")
                .attr("cx", xScale(point.factor))
                .attr("cy", yScale(point.lbm))
                .attr("r", 5)
                .attr("fill", color(point.cluster))  // Maybe I could add here a check if it the point is in the city list, to not change into cluster color
                .attr("stroke", "black");
            });
          })
          .on("mousemove", (event) => {
            tooltip.style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 10}px`);
            ;
          })
          .on("mouseout", () => {
            tooltip.style("display", "none");
            svg.selectAll("circle").remove();
            const highlightData = data.filter(d => state.city_codes.includes(d.code));

            if (highlightData) {

              highlightData.forEach(city => {
                svg.append("circle")
                .attr("cx", xScale(city.factor))
                .attr("cy", yScale(city.lbm))
                .attr("r", 5)
                .attr("fill", city.code === state.favorite ? "green" : "orange")
                .attr("stroke", "black")
                .on("mouseover", (event) => {
                  tooltip.style("display", "block")
                    .html(`Name: ${city.name}<br>LBM: ${city.lbm}<br>${column_descriptions[factorKey]}: ${city.factor}`);
                })
                .on("mousemove", (event) => {
                  
                  tooltip.style("left", `${event.pageX + 10}px`)
                    .style("top", `${event.pageY - 20}px`);
                })
                .on("mouseout", () => {
                  tooltip.style("display", "none");
                });
              });
            }
          });

        const xAxis = d3.axisBottom(xScale).ticks(5).tickFormat(d3.format(".2f"));
        const yAxis = d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".2f"));

        svg.append("g")
          .attr("transform", `translate(0, ${height})`)
          .call(xAxis)
          .append("text")
          .attr("fill", "black")
          .attr("x", width / 2)
          .attr("y", 40)
          .attr("text-anchor", "middle")
          .text(descriptions[factorKey]);

        svg.append("g")
          .call(yAxis)
          .append("text")
          .attr("fill", "black")
          .attr("transform", "rotate(-90)")
          .attr("x", -height / 2)
          .attr("y", -40)
          .attr("text-anchor", "middle")
          .text("LBM");

        if (state.city.length > 0) {
          const highlightData = data.filter(d => state.city_codes.includes(d.code));
          const selectedCity = d3.select("#selected-city");
          selectedCity.text("");

          if (highlightData) {
            highlightData.forEach(city => {

              svg.append("circle")
              .attr("cx", xScale(city.factor))
              .attr("cy", yScale(city.lbm))
              .attr("r", 5)
              .attr("fill", city.code === state.favorite ? "green" : "orange")
                .attr("stroke", "black")
              .on("mouseover", (event) => {
                tooltip.style("display", "block")
                  .html(`Name: ${city.name}<br>LBM: ${city.lbm}<br>${column_descriptions[factorKey]}: ${city.factor}`);
              })
              .on("mousemove", (event) => {
                
                tooltip.style("left", `${event.pageX + 10}px`)
                  .style("top", `${event.pageY - 20}px`);
              })
              .on("mouseout", () => {
                tooltip.style("display", "none");
              });
            });
          }       
        }
      });
    }

    // Create the Dropdowns
    function createDropdowns() {
    const container = document.getElementById("dropdown-container");
    const table = document.createElement("table");
    table.style.width = "100%"; 
    table.style.textAlign = "center"; 

    const titleRow = document.createElement("tr");

    const dropdownRow = document.createElement("tr");

    const buttonRow = document.createElement("tr");

    // Iterate through the grouped factors
    Object.entries(groupedFactors).forEach(([groupName, factors], index) => {
        //add title
        const titleCell = document.createElement("td");
        const groupTitle = document.createElement("h4");
        groupTitle.textContent = groupName;
        titleCell.appendChild(groupTitle);
        titleCell.style.textAlign = "center";
        titleRow.appendChild(titleCell);

        // add dropdown
        const dropdownCell = document.createElement("td");
        const select = document.createElement("select");
        select.classList.add("dropdown");

        const placeholder = document.createElement("option");
        placeholder.textContent = `Select a factor`;
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);

        // add options for the dropdown
        factors.forEach(factor => {
            const option = document.createElement("option");
            option.value = factor.key;
            option.textContent = factor.description;
            select.appendChild(option);
        });
        dropdownCell.appendChild(select);
        dropdownCell.style.textAlign = "center"; 
        dropdownRow.appendChild(dropdownCell);

        // add button
        const buttonCell = document.createElement("td");
        const addButton = document.createElement("button");
        addButton.textContent = "Add Factor";
        addButton.addEventListener('click', () => addFactorToPlots(select.value));
        buttonCell.appendChild(addButton);
        buttonCell.style.textAlign = "center"; 
        buttonRow.appendChild(buttonCell);
    });

    table.appendChild(titleRow);
    table.appendChild(dropdownRow);
    table.appendChild(buttonRow);

    container.appendChild(table);
}
    
    async function addFactorToPlots(selectedFactorKey) {
    try {
        if (selectedFactorKey) {
            if (factor_watch_list.includes(selectedFactorKey)) {
                alert("Factor is already on the list");
            } else {
                if (collumns_file.includes(selectedFactorKey)) {
                    factor_watch_list.push(selectedFactorKey); // ad Faktor to Watchlist 
                    updateFactorList();
                } else {
                    alert("The current granularity level does not have this factor");
                }
            }
        }
    } catch (error) {
        console.error("Error adding factor:", error);
    }
}
    async function updateFactorList() {
    const factorList = document.getElementById("factor-list");
    factorList.innerHTML = ""; 

      data_final = {};

    try {
        if (new_factors) {
            factor_watch_list = await getCorrelations(); 
        }

        new_factors = false;
        loadScatterData();

        factor_watch_list.forEach(factor => {
            const li = document.createElement("li");
            li.textContent = `${column_descriptions[factor]}`;

            const removeButton = document.createElement("span");
            removeButton.textContent = " ×";
            removeButton.style.color = "red";
            removeButton.style.cursor = "pointer";
            removeButton.style.marginLeft = "10px";

             // Add event listener to remove the factor
            removeButton.addEventListener("click", () => {
                factor_watch_list.splice(factor_watch_list.indexOf(factor), 1); // Faktor entfernen
                updateFactorList(); 
            });

            li.appendChild(removeButton);
            factorList.appendChild(li);
        });
    } catch (error) {
        console.error("Error updating factor list:", error);
    }
}

document.addEventListener("DOMContentLoaded", createDropdowns);

  </script>
  <div class="container">
    <h1>Quiz Title</h1>
    <div id="progress-bar-container">
        <div id="progress-bar"></div>
    </div>
    <div id="quiz-container"></div>
    <button id="next-button">Next Question</button>
    <div id="result-container" style="display: none;"></div>
  </div>

  <script src="script.js"></script>
</body>

</html>
